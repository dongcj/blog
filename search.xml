<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[修改 Npm 安装源为国内源]]></title>
    <url>%2Fm%2F%E4%BF%AE%E6%94%B9npm%E5%AE%89%E8%A3%85%E6%BA%90%E4%B8%BA%E5%9B%BD%E5%86%85%E6%BA%90%2F</url>
    <content type="text"><![CDATA[淘宝源地址：http://npm.taobao.org/ 删除已有 npm 包 ( 可选 ) 12345# 查看已安装的 npm packagenpm -g ls ## 删除所有 npmnpm ls -gp | awk -F/ '/node_modules/ &amp;&amp; !/node_modules.*node_modules/ &#123;print $NF&#125;' | xargs npm -g rm npm ls -g 如果报错，可以进行以下处理 : 12345678# （原因是 node-modules 中不允许用软链接，但 inherits 却用了）：npm ERR! missing: inherits@*, required by undefined@undefinednpm ERR! missing: inherits@*, required by block-stream@0.0.7npm ERR! missing: inherits@*, required by fstream@0.1.24cd /usr/lib/node_modules/unlink inheritmv inherits@2/ inherits/ 12345npm update npm -g set registry=https://registry.npm.taobao.orgnpm config set ca ""npm install npm -g set registry=https://registry.npm.taobao.orgnpm config delete ca 或者做个 cnpm 的 alias 12345678910111213141516171819# install cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org# make aliasalias cnpm="npm --registry=https://registry.npm.taobao.org \--cache=$HOME/.npm/.cache/cnpm \--disturl=https://npm.taobao.org/dist \--userconfig=$HOME/.cnpmrc"# Or alias it in .bashrc or .zshrcecho '\n#alias for cnpm\nalias cnpm="npm --registry=https://registry.npm.taobao.org \ --cache=$HOME/.npm/.cache/cnpm \ --disturl=https://npm.taobao.org/dist \ --userconfig=$HOME/.cnpmrc"' &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc# install module / sync / infocnpm install &lt;NAME&gt;cnpm sync connectcnpm info connect]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH_config_proxycommand]]></title>
    <url>%2Fm%2FSSH_config_proxycommand%2F</url>
    <content type="text"><![CDATA[ProxyCommand 12345678# 直接跳到远程计算机ssh -o "ProxyCommand ssh -p 1098 lmx@proxy.machine nc -w 1 %h %p" -p 1098 lmx@target.machine# 拷贝文件到远程计算机scp -o "ProxyCommand ssh -p 1098 lmx@proxy.machine nc -w 1 %h %p" -P 1098 -r lmx@target.machine:~/rdsAgent .# 在远程计算机执行命令ssh -o "ProxyCommand ssh -p 1098 lmx@proxy.machine nc -w 1 %h %p" -p 1098 lmx@target.machine 'ip a' ssh config file example 123456789101112131415$ cat ~/.ssh/configHost *ForwardAgent yesForwardX11 noKeepAlive yesServerAliveInterval 30CheckHostIP noControlMaster autoControlPath /tmp/ssh_mux_%h_%p_%r# client --&gt; 203.195.207.108:46707 --&gt; 118.193.254.66:22Host hk-jumpserveruser rootIdentityFile /cygdrive/c/Users/root/id_rsaProxyCommand ssh -i /cygdrive/c/Users/root/id_rsa root@203.195.207.108 -p 46707 nc 118.193.254.66 22]]></content>
  </entry>
  <entry>
    <title><![CDATA[Harbor 支持 Https]]></title>
    <url>%2Fm%2FHarbor%E6%94%AF%E6%8C%81https%2F</url>
    <content type="text"><![CDATA[新建仓库目录 1mkdir -p /opt/svicloud/tools/harbor/data/cert/ 1echo -n "svicloud85509336" &gt;/opt/svicloud/tools/harbor/data/cert/secretkey 使用 docker-compose 安装 harbor docker-compose 下载地址 12mv harbor-docker-compose-v1.2.2.yml docker-compose.yml docker-compose up -d 测试下，应该可以成功，如无法成功，运行步骤 7 （可选）修改 registry 中的证书 root.crt 和 ui 的 private_key.pem 通过 curl 请求测试 123456789101112131415curl -i https://&lt;HARBOR.DOMAIN.COM&gt;/v2/_catalogHTTP/1.1 401 UnauthorizedServer: nginx/1.11.5Date: Fri, 19 May 2017 06:45:06 GMTContent-Type: application/json; charset=utf-8Content-Length: 134Connection: keep-aliveDocker-Distribution-Api-Version: registry/2.0Www-Authenticate: Bearer realm="https://&lt;HARBOR.DOMAIN.COM&gt;/service/token",service="token-service",scope="registry:catalog:*"## 会收到一条没有认证的消息，这个正常，返回一定是 401&#123;"errors":[&#123;"code":"UNAUTHORIZED","message":"authentication required","detail":[&#123;"Type":"registry","Name":"catalog","Action":"*"&#125;]&#125;]&#125;/service/token?account=test&amp;scope=repository:test/repo:push,pull&amp;service=token-service 附：jwt 的 claim 格式 1234567891011121314151617claim = &#123; "iss": self.issuer, "sub": self.account, "aud": self.service, "exp": now + self.token_expires, "nbf": now, "iat": now, "jti": base64.b64encode(os.urandom(1024)), # TODO "access": self.access&#125;# iss 前期通过 registry.yaml 配置文件里的 issuser# sub 当前操作的帐号或者说用户名# aud 前期通过 registry.yaml 配置文件里的 service# exp 、 iat 和 nbf 表示的是 token 时间相关的# jti 是一段随机字符串# access 就是上述解析过后的 scope 删除 harbor 容器 1docker rm -f -v `docker ps -a | grep harbor | awk '&#123;print $1&#125;'` 清理安装目录 1rm -rf /opt/svicloud/tools/harbor 清理卷 1docker volume prune 清理镜像 1docker rmi dongcj/harbor-setupwrapper:v1.2.2]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 安装及命令]]></title>
    <url>%2Fm%2FDocker%E5%AE%89%E8%A3%85%E5%8F%8A%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[为了支持 bbr、aufs，必须安装 extra, 详见：Linux 升级 kernel 及 tcp_BBR 安装 Docker 12# clone 后直接脚本安装git clone https://github.com/rancher/install-docker.git docker info | grep WARN WARNING: No swap limit support 解决方法见第 1 步，配置 grub 参数 WARNING: bridge-nf-call-ip6tables is disabled 解决方法： vim /etc/sysctl.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-arptables = 1 sysctl -p CentOS 安装 Docker ( 本方法只适用于 centos6 及以下 ) yum -y install http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm yum install docker-io ( 本方法只适用于 CentOS7 及以上 ) 123456789# remove existing docker if existyum remove docker \ docker-common \ container-selinux \ docker-selinux \ docker-engine \ docker-engine-selinuxcurl -sSL -O https://get.docker.com/builds/Linux/x86_64/docker-1.10.1 &amp;&amp; chmod +x docker-1.10.1 &amp;&amp; sudo mv docker-1.10.1 /usr/local/bin/docker 针对 “Error starting daemon: Devices cgroup isn’t mounted” 的解决方法： 在 grub.conf 中添加 “cgroup_enable=memory swapaccount=1” 123456789101112131415# 配置源yum install -y yum-utilsyum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repoyum-config-manager --enable docker-ce-edge# 查找指定版本yum list docker-ce --showduplicates# 安装指定版本yum install 17.03.1.ce-1.el7.centosyum list installed | grep docker 配置 Docker 加速器（用于国内加速） 以下操作需重启 Docker 服务生效 vi /etc/docker/daemon.json 12345678&#123; "registry-mirrors": [ "https://2lqq34jg.mirror.aliyuncs.com", "https://pee6w651.mirror.aliyuncs.com", "https://registry.docker-cn.com", "http://hub-mirror.c.163.com" ]&#125; 配置 Docker 代理（用于国内加速） 123vi /etc/docker/daemon.jsonhttp_proxy=&lt;IP_ADDR&gt;:&lt;PORT&gt; https_proxy=&lt;IP_ADDR&gt;:&lt;PORT&gt; dockerd 安装 docker-compose 123456789101112131415# docker-compose VERSION:# https://github.com/docker/compose/releases# get the latest infoDOCKER_COMPOSE_ARCH=docker-compose-Linuxcurl -s https://api.github.com/repos/docker/compose/releases/latest | \ jq -r ".assets[] | select(.name | test(\"$&#123;DOCKER_COMPOSE_ARCH&#125;\")) | .browser_download_url"# download the latest versiondockerComposeVersion=1.18.0curl -L https://github.com/docker/compose/releases/download/$dockerComposeVersion/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composedocker-compose --version 安装 docker-machine 123456789101112curl -L https://github.com/docker/machine/releases/download/v0.9.0/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machinechmod +x /tmp/docker-machinecp /tmp/docker-machine /usr/local/bin/docker-machine# 使用 docker-machine( 支持 virtualbox、阿里云等 )# 所有的 Available driver plugins：&gt; https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md# create aws machinedocker-machine create --driver amazonec2 --amazonec2-access-key AKI******* --amazonec2-secret-key 8T93C******* aws-sandboxdocker-machine create --driver none --url=tcp://192.168.1.112:2376 svi1r01n02 Docker 常用配置 如果是 systemctl 启动的 docker, 需要在 /lib/systemd/system/docker.service 中修改 12345## 配置 Docker 启动参数：（在 /etc/default/docker 中）DOCKER_OPTS="--storage-driver=aufs --tls=true --tlscert=/var/docker/server.pem --tlskey=/var/docker/serverkey.pem -H tcp://192.168.1.112:2376"other_args="--exec-driver=lxc \ --selinux-enabled [-H tcp://0.0.0.0:2376] [-b=br0]" # 如果用了 -H，连接时也要用 -H 指定 !! 12345# 前台启动docker -d -b br0# 加入默认选项以使 service 生效other_args="--exec-driver=lxc --selinux-enabled -b=br0" 映射为 container 内部盘，可以自定义使用 read、write、mknode 操作 docker run --device=/dev/sdc:/dev/xvdc:[rwm] --device=/dev/sdd --device=/dev/zero:/dev/nulo -i -t ubuntu ls -l /dev/{xvdc,sdd,nulo} Restart policies docker run --restart=[always|no|on-failure|unless-stopped] redis 向容器中增加主机名与 IP 对应 (add /etc/hosts entry) docker run --add-host=docker:10.180.0.1 --rm -it debian 设置容器的 ulimit docker run --ulimit nofile=1024:1024 --rm debian sh -c &quot;ulimit -n&quot; Docker 重启 daemon 不重启 container 123# 以下二种方法任一种都可以 - 将 /etc/docker/daemon.json 中的 "live-restore" 设置为 true，然后 SIGHUP（kill -HUP PID） - sudo dockerd --live-restore 可以使用 –config-file 指定，默认位置为 /etc/docker/daemon.json 123456789101112131415161718192021222324252627282930313233&#123; "authorization-plugins": [], "bridge": "", "cluster-advertise": "", "cluster-store": "", "debug": true, "default-ulimits": &#123;&#125;, "disable-legacy-registry": false, "dns": [], "dns-opts": [], "dns-search": [], "exec-opts": [], "fixed-cidr": "", "graph": "", "group": "", "hosts": [], "insecure-registries": [], "labels": [], "live-restore": true, "log-driver": "", "log-level": "", "mtu": 0, "pidfile": "", "raw-logs": false, "registry-mirrors": [], "storage-driver": "", "storage-opts": [], "swarm-default-advertise-addr": "", "tlscacert": "", "tlscert": "", "tlskey": "", "tlsverify": true&#125; Docker 的 API 操作 12345678# 镜像curl --unix-socket /var/run/docker.sock http://localhost/images/json# eventscurl --no-buffer -XGET --unix-socket /var/run/docker.sock http://localhost/events# container 信息curl --unix-socket /var/run/docker.sock "http://localhost/containers/json?all=1&amp;before=8dfafdbc3a40&amp;size=1" set metadata on container 12345678910# ( 如下设置了一个 my-label="" 和 com.example.foo=bar)docker run -l my-label --label com.example.foo=bar ubuntu bashdocker run --label-file ./labels ubuntu bash# cat ./labelscom.example.label1="a label"# this is a commentcom.example.label2=another\ labelcom.example.label3 直接设置 sysctl( 不能与 –network=host 同用 ) docker run --sysctl net.ipv4.ip_forward=1 ubuntu 从 container 的变化中新建一个 image docker commit $CONTAINER_ID [REPOSITORY[:TAG]] 常用 Docker 命令 docker run --rm --volume-from dbdata -v ${pwd}:/backup ubuntu tar cvf /backup/backup.tar /dbdata 已运行容器通过 iptbles 来 nat iptables -t nat -A DOCKER -p tcp --dport 3306 -j DNAT --to-destination 172.17.0.2:3306 Docker Inspect 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 如果镜像和实例名字重名，使用 --type 区分docker inspect --type=image rhel7container_ip=$(docker inspect --format '&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' $&#123;container_id&#125;)docker inspect `docker ps -q` | grep IPAddress | cut -d '"' -f 4# 或者docker inspect `dl` | jq -r '.[0].NetworkSettings.IPAddress'# get the IP address of a containerdocker inspect \ --format='&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' \ d2cc496561d6172.17.0.2docker inspect --format '&#123;&#123;json .Mounts&#125;&#125;' pensive_blackwelldocker inspect --format "&#123;&#123;lower .Name&#125;&#125;" pensive_blackwell# Listing all port bindingsdocker inspect \ --format='&#123;&#123;range $p, $conf := .NetworkSettings.Ports&#125;&#125; \ &#123;&#123;$p&#125;&#125; -&gt; &#123;&#123;(index $conf 0).HostPort&#125;&#125; &#123;&#123;end&#125;&#125;' \ d2cc496561d6 80/tcp -&gt; 80# Getting size information on a containerdocker inspect -s d2cc496561d6 | grep -i Size# 找到 container 的 pidPID=$(docker inspect --format &#123;&#123;.State.Pid&#125;&#125; &lt;container_name_or_ID&gt;)docker inspect -f '&#123;&#123;.Config.Image&#125;&#125;' 5cf58382b2f0# logging driverdocker inspect -f '&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;' &lt;CONTAINER&gt;sut_ip=$&#123;BOOT_2_DOCKER_HOST_IP&#125;template='&#123;&#123; range $key, $value := .NetworkSettings.Ports &#125;&#125;&#123;&#123; $key &#125;&#125;='"$&#123;BOOT_2_DOCKER_HOST_IP&#125;:"'&#123;&#123; (index $value 0).HostPort &#125;&#125; &#123;&#123; end &#125;&#125;'tomcat_host_port=$(docker inspect --format="$&#123;template&#125;" $&#123;container_id&#125;)for line in $&#123;tomcat_host_port&#125; ; do echo "$&#123;line&#125;" &gt;&gt; $&#123;work_dir&#125;/docker_container_hosts.propertiesdone 详见：https://docs.docker.com/engine/admin/logging/overview/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Awk 命令]]></title>
    <url>%2Fm%2Fawk%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[tegories: thor: dongcj ntwk@163.com tegories: author: dongcj ntwk@163.com categories: - author: dongcj ntwk@163.com categories: - author: dongcj ntwk@163.com categories: - author: dongcj ntwk@163.com categories: - author: dongcj ntwk@163.com categories: - author: dongcj ntwk@163.com categories: - author: dongcj ntwk@163.com categories: - updated: date: author: dongcj ntwk@163.com 123456789101112131415161718msg=$(awk ' BEGIN &#123; IGNORECASE = 1; ORS = "%20" &#125; /FAILED|ERROR/ &#123; gsub(/[[:blank:]]+(FAILED|ERROR)/, "") gsub(/[[:blank:]]+/, "_")gsub(/[^[:alnum:]_]/, "") print &#125;' \ /var/clone/check/check_baseos.log \ /var/clone/check/check_gemstone_init.log \ /var/clone/check/check_pe_profile.log \ /var/clone/check/check_agent.log 2&gt;/dev/null | cut -c1-70)``` # 计算第三列的总和```awkawk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile awk 内建变量示例详解之 NR、FNR、NF、FILENAME NR: Number of Record NF: Number of Field 123456789101112131415cat class1.txtzhaoyun 85 87guanyu 87 88liubei 90 86cat class2.txtcaocao 92 87 90guojia 99 96 92awk '&#123;print FILENAME,"NR="NR,"FNR="FNR,"$"NF"="$NF&#125;' class1.txt class2.txtclass1.txt NR=1 FNR=1 $3=87class1.txt NR=2 FNR=2 $3=88class1.txt NR=3 FNR=3 $3=86class2.txt NR=4 FNR=1 $4=90class2.txt NR=5 FNR=2 $4=92]]></content>
  </entry>
  <entry>
    <title><![CDATA[Rancher 安装]]></title>
    <url>%2Fdocker%2FRancher%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[准备步骤 如果不配置时间同步，可能会导致调度服务有可能不正常 最好使用 UTC time: rm -rf /etc/localtime 支持 BBR，请升级内核至 4.9 以上版本（弱网环境建议） 如果要支持 aufs，请安装 linux-image-extra 的包 重要：所有服务器需要设置外部 DNS 12345678# stop and disable the local dns generatorsystemctl disable systemd-resolved.service;systemctl stop systemd-resolved.service;systemctl status systemd-resolved.service;vi /etc/network/interfacesdns-nameservers 114.114.114.114 设置 hostname [root@rancher-server] echo &quot;&lt;HOSTNAME&gt;&quot; &gt;/etc/hostname &amp;&amp; hostname &lt;HOSTNAME&gt; [root@rancher-server] hostnamectl set-hostname svi1r01n08 install docker 123456789# 国内 DaoCloud 镜像安装curl -sSL https://get.daocloud.io/docker | sh# Rancher 官方安装脚本git clone https://github.com/rancher/install-docker.gitcd ./install-docker &amp;&amp; bash &lt;LATEST__XX&gt;.sh# Docker 开机自启动systemctl enable docker.service 配置 docker 加速器（用于国内加速） 12vi /etc/docker/daemon.json# 编辑完后重启 docker 生效 12345678&#123; "registry-mirrors": [ "https://2lqq34jg.mirror.aliyuncs.com", "https://pee6w651.mirror.aliyuncs.com", "https://registry.docker-cn.com", "http://hub-mirror.c.163.com" ]&#125; 安装 Rancher 单机安装 1234docker pull rancher/serverdocker run -d --restart=always \-v /opt/svicloud/rancher/server_db:/var/lib/mysql \--name rancher-server -p 8080:8080 rancher/server HA 模式安装（可选） 安装一个外部主从模式的 MySQL 在主备两边执行 123456789101112131415docker run -d --restart=unless-stopped -p 8080:8080 -p 9345:9345 --name rancher-server rancher/server \ --db-host myhost.example.com \ --db-port 3306 \ --db-user username \ --db-pass password \ --db-name cattle \ --advertise-address &lt;IP_of_the_Node&gt;db.cattle.database=mysqldb.cattle.username=cattledb.cattle.password=cattledb.cattle.mysql.host=localhostdb.cattle.mysql.port=3306db.cattle.mysql.name=cattle# All values above are the defaults except db.cattle.database. If the defaults are fine, then all you need to set is db.cattle.database=mysql. 启动集群模式（可选） 1234# 手动启动主docker run -d --restart=unless-stopped -p 8080:8080 -p 9345:9345 --name rancher-server rancher/server --db-host 192.168.1.174 --db-port 3306 --db-user cattle --db-pass cattle --db-name cattle --advertise-address 192.168.1.174docker run -d --restart=unless-stopped -p 8080:8080 -p 9345:9345 --name rancher-server rancher/server --db-host 192.168.1.174 --db-port 3306 --db-user cattle --db-pass cattle --db-name cattle --advertise-address 192.168.1.184 设置 Rancher ssl 12345678910111213mkdir -p /opt/svicloud/rancher/certcp cert.pem key.pem /opt/svicloud/rancher/certdocker run -d \--restart=always \--name rancher-server-ssl \--link rancher-server \-p 80:80 -p 443:443 \-e 'RANCHER_URL=&lt;YOUR_DOMAIN&gt;' \-e 'RANCHER_CONTAINER_NAME=rancher-server' \-e 'RANCHER_PORT=8080' \-v /opt/svicloud/rancher/cert:/etc/nginx/external/ \codedevote/nginx-ssl-proxy-rancher 使用 Salt 进行自动化安装 Server、agent 参见 GitHub：komljen/rancher-salt registry v2 版本的查询所有镜像： https://github.com/docker/distribution/blob/master/docs/spec/api.md#deleting-an-image 123456789101112# 1. 先查出所有的镜像curl https://192.168.1.111/v2/_catalog# 2. 查出该镜像的 tag 列表curl https://192.168.1.111/v2/dongcj/webserver/tags/listcurl https://192.168.1.111/v2/dongcj/webserver/manifests/v0.1# 4、删除所给的镜像https://github.com/burnettk/delete-docker-registry-image# 或者使用 ui 进行操作 将日志展示在 WEB UI 的日志中 /var/log/nginx/error.log -&gt; /dev/stderr /var/log/ngnix/access.log -&gt; /dev/stdout 自定义加入 rancher 网络 在启动参数中加入 --label io.rancher.container.network=true，这样网络就会有 rancher 的网络 IP 1234# 需要在启动 agent 的参数中加 environment: CATTLE_AGENT_IP=&lt;HOST_IP&gt;sudo docker run -d -e CATTLE_AGENT_IP=&lt;HOST_IP&gt; --privileged \ -v /var/run/docker.sock:/var/run/docker.sock \ rancher/agent:v0.8.2 http://SERVER_IP:8080/v1/scripts/xxxx 123# external 的 DNS 设置方法相同# 进入 network-services-metadata-dns-X.cat /etc/rancher-dns/answers.json Rancher LB http redirect to https 1234frontend http-frontend bind *:80 mode http redirect scheme https code 301 if !&#123; ssl_fc &#125; Rancher LB 使用 IP Hash 在 自定义 Haproxy.cfg 中增加以下内容 : 1balance source]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>rancher</tag>
        <tag>docker</tag>
        <tag>caas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2Flinux%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[[+]新增 [-]删除 [^]升级 [#]修复 高亮 tail -f 搜索 1. less xxx.log 2. 搜索你要高亮的关键字 3. SHIFT+F，进入 follow 模式 Windows Windows mount 网络共享为一个文件夹 net use \\192.168.11.111\public\data mklink /d d:\ccc \\192.168.11.111\public\data Windows 网络设置 123ipconfig | findstr /c:&quot;IPv4&quot;sed -i -e &quot;s/$/\x0d/g&quot; $&#123;MountPoint&#125;/temp/postAfter.d/m01.configureNetworkInterfaces.batnetsh interface ip show interfaces &quot; 本地连接 &quot; windows 如何删除隐藏设备 set devmgr_show_nonpresent_devices=1 devmgmt.msc 打开隐藏设备 映射 samba 至 windows net use z: \\192.168.96.207\cloud-storage-greatwall greatwall /USER:root /PERSISTENT:NO 映射 samba 至 Linux 123# 注意：一定要有 mount.cifs 才可以，如 Ubuntu 需要安装apt-get install smbfsmount [-t cifs] -o username=root,password=passw0rd //192.168.88.181/public /mnt smbstatus 可以查看目前有哪些连接 Mount webdav 12# 安装 fuse, davfs2, neon-develmount.davfs &lt;http://192.168.3.3/webdav /mnt/&gt; Suse 添加 rc.local 123456789rc_local=/etc/rc.localcurrent_runlevel=$(runlevel | awk &apos;&#123; print $NF &#125;&apos;) if [ -x $rc_local ];then ((current_runlevel&gt;1)) &amp;&amp; ((current_runlevel&lt;6)) &amp;&amp; &#123; echo -e &quot;\n\n\n&quot; echo &quot;-----------------------Startup $rc_local---------------------------&quot; $rc_local &#125;fi ( 记得需要 chmod 755 /etc/rc.local) 单个文件 diff -uN from-file to-file &gt;to-file.patch patch -p0 &lt; to-file.patch patch -RE -p0 &lt; to-file.patch 多个文件 diff -uNr from-docu to-docu &gt;to-docu.patch patch -p1 &lt; to-docu.patch patch -R -p1 &lt;to-docu.patch 证书生成及加解密 查看证书 12345# 生成 16 位的随机数openssl rand -hex 8# 查看证书信息openssl x509 -text -noout -in /var/lib/puppet/ssl/certs/ca.pem 使用 openssl 生成 openssl genrsa -des3 -out server.key 1024 openssl req -new -key server.key -out server.csr cp server.key server.key.org openssl rsa -in server.key.org -out server.key openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt 使用证书生成工具 wget https://dl.eff.org/certbot-auto chmod a+x certbot-auto ./certbot-auto ./certbot-auto certonly --standalone -d &lt;YOUR_DOMAIN.COM&gt; cp /etc/letsencrypt/live/&lt;YOUR_DOMAIN.COM&gt;/fullchain.pem /home/certs/ cp /etc/letsencrypt/live/&lt;YOUR_DOMAIN.COM&gt;/privkey.pem /home/certs/ tar -czf - Desktop/ | openssl des3 -out my.tar.gz openssl des3 -d -in my.tar.gz | tar -xzvf - Linux IP IP 地址过滤 1234ip addr show eth0 | awk '/inet /&#123;split($2,x,"/");print x[1]&#125;'ifconfig eth0 | awk '&#123;if ( $1 == "inet" &amp;&amp; $3 ~ /^Bcast/) print $2&#125;' | awk -F: '&#123;print $2&#125;'ifconfig -a | grep -oE '[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;'| head -1ifconfig -a | perl -e '&#123;while(&lt;&gt;)&#123;if(/inet (?:addr:)?([\d\.]+)/i)&#123;print $1,"\n";last;&#125;&#125;&#125;' 12345678910111213# get the ether listNET_DEV_PREFIX="^eno|^eth|^em|^br|^bond"NET_ETHER_LIST=`ifconfig -a | egrep '^[^ ]' | awk '&#123; print $1 &#125;' | egrep "$&#123;NET_DEV_PREFIX&#125;" | tr -d ':' | xargs`[ -z "$NET_ETHER_LIST" ] &amp;&amp; echo " Can not get the network ether list, exit" &amp;&amp; exit 1# get the first ip &amp; maskFIRST_NET_ETHER=$(echo "$NET_ETHER_LIST" | awk '&#123;print $1&#125;')# on centosIP_ADDRESS_NETMASK=`ifconfig $FIRST_NET_ETHER | grep "inet addr" | sed "s/inet addr:\(.*\) Bcast:.* Mask:\(.*\)/\1 \2/" | head -1 | xargs`# on ubuntuIP_ADDRESS=`ifconfig $FIRST_NET_ETHER | grep -w "inet" | awk '&#123;print $2&#125;'` Ubuntu IP 配置 1234567891011121314151617181920212223242526auto eth0iface eth0 inet static address 192.168.88.20 netmask 255.255.255.0 network 192.168.88.0 broadcast 192.168.88.255 gateway 192.168.88.1 # dns-* options are implemented by the resolvconf package, if installed dns-nameservers 192.168.88.1# Bridge IP to eth1auto br100iface br100 inet static address 192.168.89.20 network 192.168.89.0 netmask 255.255.255.0 broadcast 192.168.89.255 gateway 192.168.89.1 bridge_ports eth1 bridge_stp off bridge_fd 0 bridge_maxwait 0 post-up echo 1 &gt; /proc/sys/net/ipv4/ip_forward post-up iptables -t nat -A POSTROUTING -s '10.10.10.0/24' -o eth0 -j MASQUERADE post-down iptables -t nat -D POSTROUTING -s '10.10.10.0/24' -o eth0 -j 1234567891011# Ubuntu 绑定多个 IPauto eth0iface eth0 inet staticaddress 192.168.88.10netmask 255.255.255.0gateway 192.168.88.1auto eth0:1iface eth0:1 inet staticaddress 192.168.8.10netmask 255.255.255.0 CentOS IP 配置 1234567891011121314151617181920212223242526272829303132vi /etc/sysconfig/network-scripts/ifcfg-br0DEVICE="br0"NM_CONTROLLED="NO"ONBOOT=yesTYPE=BridgeBOOTPROTO=staticIPADDR=192.168.88.1PREFIX=24GATEWAY=192.168.88.254DNS1=192.168.88.1DOMAIN=szhcf.com.cnDEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=noNAME="System br0"# 原来的 eth0 去掉 IP 相关信息vi /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE="eth0"HWADDR="14:DA:E9:07:C6:B6"NM_CONTROLLED=noONBOOT="yes"#IPADDR=192.168.88.1#NETMASK=255.255.255.0#GATEWAY=192.168.88.254#DNS1=192.168.8.1#DEFROUTE=yes#IPV4_FAILURE_FATAL=yes#IPV6INIT=noNAME="System eth0"#UUID=5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e09BRIDGE=br0 RedHat 绑定多个 IP 12345678910111213141516171819202122cp /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0:1 DEVICE=&apos;eth0&apos;TYPE=&apos;Ethernet&apos;STARTMODE=&apos;onboot&apos;BOOTPROTO=&apos;static&apos;IPADDR=&apos;172.16.12.139/16&apos;NETMASK=&apos;255.255.0.0&apos;GATEWAY=&apos;172.16.0.254&apos;DNS=&apos;8.8.8.8&apos;DNS_1=&apos;172.16.12.110&apos;BROADCAST=&apos;&apos;ETHTOOL_OPTIONS=&apos;&apos;MTU=&apos;&apos;NAME=&apos;&apos;NETWORK=&apos;&apos;REMOTE_IPADDR=&apos;&apos;USERCONTROL=&apos;no&apos;IPADDR_1=&apos;10.100.150.1&apos;NETMASK_1=&apos;255.255.0.0&apos;LABEL_1=&apos;1&apos; ＝＝》 这个必须添加 使用以下命令可以更新网域内的 arp arping -U 10.85.138.111 -A -I br0 -c 1（需要 10.85.138.111 这个 IP 在本机上） snip find 按时间查找文件 # touch 来新建一个合适的参照文件 $ touch -t 201205280000 reference_file $ find . -newer reference_file $ find . ! -newer reference_file 查看父进程与子进程树 ps axf 显示关系 ps aux 显示 CPU/MEM ps aux | cat - 可以显示完整的命令行参数 cd iso rm -f md5sums; find -type f -not -name md5sums -not -name boot.cat -exec md5sum {} \; &gt;&gt; md5sums.txt 123456789101112131415161718192021222324252627282930313233343536# 先增加实例文件大小，可以使用 dd 命令dd if=/dev/zero of=/tmp/temp_expand bs=1M count=4096（增加 4G）cat /tmp/temp_expand &gt;&gt;/var/lib/libvirt/images/my_vm.img# 挂载文件至系统，以便找出是否有 swap devicekpartx -a -p p /var/lib/libvirt/images/my_vm.img# If has swap device, del the swap deviceswapDevice=`sfdisk -s -l /dev/loop1 | grep -e 'Linux swap' |awk '&#123;print $1&#125;'`# Del swapparted -s $&#123;loop&#125; rm $&#123;swap_part_num&#125;# If does't have, add the new swap deviceparted -s /dev/loop1 "unit mb mkpart primary linux-swap -2048MB -0"或者先只划分空间，再用 mkswap 进行操作可选的：mkswap -v1 /dev/mapper/loop1p3# 重新刷新新增加的 swap 设备kpartx -d -p p /var/lib/libvirt/images/my_vm.imgkpartx -a -p p /var/lib/libvirt/images/my_vm.img# 将新的 lo 设备分区进行打印sfdisk -d $dev_name &gt;/tmp/sfdisk_dump# 如果有 swap 分区，则 root 分区为 (root start), (swap start - root start)；如果没有 , 则为 (root start),new_root=401625,14227239( 例子 )converted_root_device=`echo "/dev/loop1p2" | sed -e 's/\//\\\\\//g'`sed -e "s/^$&#123;converted_root_device&#125;.*$/$new_root/" /tmp/sfdisk_dump | sfdisk --no-reread --force /dev/loop1# 重新刷新新变更的分区kpartx -d -p p /var/lib/libvirt/images/my_vm.imgkpartx -a -p p /var/lib/libvirt/images/my_vm.img# fs resizee2fsck -pv /dev/mapper/loop1p2resize2fs -f /dev/mapper/loop1p2 rpm usage 12345678910111213查看系统中所有已经安装的包：rpm -qa 如果分页查看加上｜ more查询一个已经安装的文件属于哪个软件包：rpm -qf 文件名查询已安装软件包都安装到何处：rpm -ql 软件名 或 rpmquery -ql 软件名查询一个已安装软件包的信息：rpm -qi 软件名查看一下已安装软件的配置文件：rpm -qc 软件名查看一个已经安装软件的文档安装位置：rpm -qd 软件名查看一下已安装软件所依赖的软件包及文件：rpm -qR 软件名查看一个软件包的用途、版本等信息：rpm -qpi file.rpm查看一件软件包所包含的文件：rpm -qpl file.rpm查看软件包的文档所在的位置：rpm -qpd file.rpm查看一个软件包的配置文件：rpm -qpc file.rpm查看一个软件包的依赖关系：rpm -qpR file.rpm apt-get、dpkg、apt-cache 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# apt-get install packagename ——安装一个新软件包（参见下文的 aptitude）# apt-get remove packagename ——卸载一个已安装的软件包（保留配置文件）# apt-get --purge remove packagename ——卸载一个已安装的软件包（删除配置文件）# apt-get autoclean apt 会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件# apt-get clean 这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。# apt-get upgrade ——更新所有已安装的软件包# apt-get dist-upgrade ——将系统升级到新版本# dpkg -i --force-overwrite-i package 强制安装软件# dpkg -i --force-all package 不顾一切的强制安装软件# dpkg -r --purge --force-deps package 强制移除软件# dpkg -P package 删除包（包括配置文件）# dpkg -l "*package*" 显示该包的版本等相关信息 ( 可通配 )# dpkg --get-selections 列出系统中所有安装的软件# dpkg -L package 列出与该包关联的文件# dpkg -I package 显示特定包的详细信息# dpkg -unpack package.deb 解开 deb 包的内容# dpkg -s package 报告特定包的状态# dpkg -S keyword 搜索所属的包内容# dpkg -c package.deb 列出 deb 包的内容First column: Desiredu for Unknowni for Installr for Removep for Purgeh for HoldSecond column: Statusn for Not Installedi for Installedc for Config-filesu for Unpackedf for Failed-configh for Half-installedThird column: Err? (error?) — If in uppercase, bad errors. for (none)h for Holdr for Reinst-requiredx for both-problems# apt-file search]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rfw-RemoteFirewall 远程管理防火墙]]></title>
    <url>%2Flinux%2Fsecurity%2FRfw-RemoteFirewall%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[install &gt; client: curl client (eg: 116.23.45.8) &gt; server: rfw servers (default port: 7393) install rfw on ALL server(on client &amp; server) $ git clone https://github.com/securitykiss-com/rfw.git $ cd rfw &amp;&amp; python setup.py install generate remote crt(on client) $ cd /etc/rfw/deploy/ $ rfwgen 11.11.11.11 $ rfwgen 22.22.22.22 # will generate the follow files . ├── client │ └── ca.crt ├── offline │ └── ca.key ├── server_11.11.11.11 │ ├── server.crt │ └── server.key └── server_22.22.22.22 ├── server.crt └── server.key copy key to server 12345# on master serverscp /etc/rfw/deploy/server_11.11.11.11/server.key root@11.11.11.11:/etc/rfw/ssl/scp /etc/rfw/deploy/server_11.11.11.11/server.crt root@11.11.11.11:/etc/rfw/ssl/scp /etc/rfw/deploy/server_22.22.22.22/server.key root@22.22.22.22:/etc/rfw/ssl/scp /etc/rfw/deploy/server_22.22.22.22/server.crt root@22.22.22.22:/etc/rfw/ssl/ edit the server config $ vi /etc/rfw/rfw.conf outward.server.certfile = /etc/rfw/ssl/server.crt outward.server.keyfile = /etc/rfw/ssl/server.key auth.username = your_username_here auth.password = your_password_here $ vi /etc/rfw/white.list 116.23.45.8 start rfw(on server) $ rfw &amp; $ iptables -L -n Chain INPUT (policy ACCEPT) target prot opt source destination ACCEPT tcp -- 116.23.45.8 0.0.0.0/0 tcp dpt:7393 DROP tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:7393 Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination ACCEPT tcp -- 0.0.0.0/0 116.23.45.8 tcp spt:7393 DROP tcp -- 0.0.0.0/0 0.0.0.0/0 tcp spt:7393 test on client # block some bad IP for 5 minutes: $ curl -i --cacert /home/me/ca.crt --user your_username_here:your_password_here -XPUT https://11.11.11.11:7393/drop/eth/1.2.3.4?expire=5m # Check if the rule is present now and not present after 5 minutes: $ curl -i --cacert /home/me/ca.crt --user your_username_here:your_password_here https://11.11.11.11:7393/list]]></content>
      <categories>
        <category>linux</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>rfw</tag>
        <tag>RemoteFirewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2.6 升级至 python2.7]]></title>
    <url>%2Flinux%2FPython2.6%E5%8D%87%E7%BA%A7%E8%87%B3python2.7%2F</url>
    <content type="text"><![CDATA[升级 python install # 一定要先安装 zlib zlib-devel openssl openssl-devel，ncurses-devel，不然安装好后没有 zlib, 和 HTTPlib $ yum -y install zlib-devel openssl-devel ncurses-devel libxml2-devel $ yum -y install mysql mysql-devel $ yum -y install libxml2-devel libxslt-devel 编译安装 python 新版 $ wget http://www.python.org/ftp/python/2.7.13/Python-2.7.13.tgz # 加上 --enable-shared 解决 &quot;Cannot build PL/Python because libpython is not a shared library&quot; $ tar -xzf Python-2.7.13.tgz &amp;&amp; cd Python-2.7.13 &amp;&amp; ./configure --enable-shared $ make all &amp;&amp; make install &amp;&amp; make clean &amp;&amp; make distclean $ echo &quot;/usr/local/lib&quot; &gt;&gt;/etc/ld.so.conf $ ldconfig $ mv /usr/bin/python /usr/bin/python2.6.bak $ ln -s /usr/local/bin/python /usr/bin/python # copy bz2 module $ yes | cp -rLfap /usr/lib64/python2.*/lib-dynload/bz2.so /usr/local/lib/python2.*/ $ python -V 安装 easy_install 和 pip # 参见：[《linux 安装 easy_install 及 pip》][1] 修改 yum 中的 python 版本为 python2.6 $ vi /usr/bin/yum $ vi /usr/bin/yum-config-manager 安装一些基础软件 $ pip install readline $ pip install MySQL-python pssh flask $ pip install lxml virtualenv virtualenvwrapper websockify]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>python 升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Printf 进行格式化]]></title>
    <url>%2Flinux%2F%E4%BD%BF%E7%94%A8printf%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[表格输出 123456789101112131415161718#/bin/bashdivider===============================divider=$divider$dividerheader="\n %-10s %8s %10s %11s\n"format=" %-10s %08d %10s %11.2f\n"width=43printf "$header" "ITEM NAME" "ITEM ID" "COLOR" "PRICE"printf "%$width.$&#123;width&#125;s\n" "$divider"printf "$format" \Triangle 13 red 20 \Oval 204449 "dark blue" 65.656 \Square 3145 orange .7 123456789101112131415161718192021222324252627282930printf "%s\n" "1" "2" "\n3"12\n3printf "%b\n" "1" "2" "\n3"123$printf "%d\n" 255 0xff 0377 3.5255255255bash: printf: 3.5: invalid number3printf "%f\n" 255 0xff 0377 3.5255.000000255.000000377.0000003.500000printf "%.1f\n" 255 0xff 0377 3.5255.0255.0377.03.5 12for i in $( seq 1 10 ); do printf "%03d\t" "$i"; done001 002 003 004 005 006 007 008 009 010]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>printf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMATE、XFCE、VNC 配置]]></title>
    <url>%2Flinux%2FSMATE%E3%80%81XFCE%E3%80%81VNC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[YUM 安装图像界面及 VNC ( 参考：http://www.ha97.com/4634.html ) yum install epel-release yum grouplist yum groupinstall &quot;GNOME Desktop Environment&quot;（CentOS 5.x 安装 GNOME 桌面环境） yum groupinstall &quot;X Window System&quot; &quot;Desktop&quot;（CentOS 6.x 安装 GNOME 桌面环境） yum groupinstall [ xfce | &quot;MATE Desktop&quot; ]（CentOS 安装 xfce 桌面环境，可选） # runlevel 5 systemctl isolate graphical.target # Start the GUI on boot systemctl set-default graphical.target # 切换 display manager # 查看 ls -l /etc/systemd/system/display-manager.service # 切换 systemctl disable gdm &amp;&amp; systemctl enable lightdm # 刷新 systemctl isolate graphical.target 安装 vnc server # 安装 Xfce 要使用 vncserver，需修改 /root/.vnc/xstartup 里为 exec /bin/sh /etc/xdg/xfce4/xinitrc 即可 yum install vnc-server vnc* （CentOS 5.x 里） yum install tigervnc-server tigervnc （CentOS 6.x 里） /etc/init.d/vncserver restart # 关闭具体的 vncserver 命令 : vncserver -kill :1 http://jensd.be/125/linux/rhel/install-mate-or-xfce-on-centos-7]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>xorg</tag>
        <tag>smate</tag>
        <tag>xfce</tag>
        <tag>vnc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 部署 Lazy-Balancer 负载均衡]]></title>
    <url>%2Flinux%2FCentOS%E9%83%A8%E7%BD%B2lazy-balancer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[clone soft $ git clone https://github.com/v55448330/lazy-balancer.git /usr/local/lazy_balancer $ cd /usr/local/lazy_balancer install tengine $ git submodule update --init --recursive $ cd resource/nginx/tengine $ yum -y install pcre-devel $ ./configure --user=nginx --group=nginx --prefix=/etc/nginx --sbin-path=/usr/sbin --error-log-path=/var/log/nginx/error.log --conf-path=/etc/nginx/nginx.conf --pid-path=/var/run/nginx.pid $ make &amp;&amp; make install # add nginx user $ adduser --system --no-create-home --shell /bin/false nginx install supervisor $ yum -y install supervisor # add to supervisor config file $ echo &quot;[include]&quot; &gt;&gt;/etc/supervisord.conf $ echo &quot;files = /etc/supervisor/conf.d/*.conf&quot; &gt;&gt;/etc/supervisord.conf $ cp -rf /usr/local/lazy_balancer/service/* /etc/supervisor/ $ vi /etc/supervisor/conf.d/supervisor_balancer.conf start service $ service supervisor restart]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>tengine</tag>
        <tag>lazy-balancer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 升级 Kernel 及 tcp_BBR]]></title>
    <url>%2Flinux%2FLinux%E5%8D%87%E7%BA%A7kernel%E5%8F%8Atcp_BBR%2F</url>
    <content type="text"><![CDATA[快速自动化安装方法（仅支持 Debian6+ / Ubuntu14+） wget -N –no-check-certificate https://softs.pw/Bash/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; bash bbr.sh 12345678# 这二个是打开 BBR 必需的echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.confecho "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf# 保存生效sysctl -plsmod | grep bbr Debian、Ubuntu 升级内核 1234567891011121314151617# 直接使用 apt-get 安装内核apt-get updateapt-cache search linux-image-extra# 安装最新的内核apt-get install linux-image-extra-&lt;NEWEST_KERNEL_RELEASE&gt;dpkg -l | grep linux-imageapt-get remove &lt;OLD_KERNEL_RELEASE&gt;update-grubreboot# 查看一下目前的内核版本# 应该是显示为 &lt;NEWEST_KERNEL_RELEASE&gt;uname -r RHEL、CentOS 升级内核 1234567891011121314151617181920212223242526272829yum update -yrpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org# 如果是 el7rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm# 如果是 el6rpm -Uvh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm# 安装内核yum --enablerepo=elrepo-kernel install kernel-ml# 查看当前已安装的内核awk -F\' '$1=="menuentry " &#123;print i++ " : " $2&#125;' /etc/grub2.cfg# 设定默认内核 (centos7)grub2-set-default 0reboot# 设定默认内核 (centos6)vi /etc/grub.conf# 修改 default=&lt;ID 号 &gt;# 设定 /etc/sysctl.confnet.core.default_qdisc = fqnet.ipv4.tcp_congestion_control = bbr# 生效sysctl -p 下载内核二进制包 链接：http://mirrors.kernel.org/debian/pool/main/l/linux/ 解压安装 123456ar x linux-image-4.9.0-11-generic_4.9.0-11.12_amd64_5.debbzip2 -d data.tar.bz2tar -xf data.tarinstall -m644 boot/vmlinuz-4.9.0-11-generic /boot/vmlinuz-4.9.0-11-genericcp -Rav lib/modules/4.9.0-11-generic/ /lib/modules/depmod -a 4.9.0-11-generic 加入引导 12345dracut -f -v --hostonly -k '/lib/modules/4.9.0-11-generic' /boot/initramfs-4.9.0-11-generic 4.9.0-11-generic# 注 : centos7 和 6 的步骤不同，centos6 是 grub，需要手动自动写 , 但注意：root=UUID= 那里的 uuid 不能修改！！！；# centos7 是 grub2 可以用下面命令 :grub2-mkconfig -o /boot/grub2/grub.cfg 修改引导顺序 查看引导内有哪些内核 12345678910cat /boot/grub2/grub.cfg |grep menuentrycat /boot/grub2/grub.cfg |grep menuentryif [ x"$&#123;feature_menuentry_id&#125;" = xy ]; then menuentry_id_option="--id" menuentry_id_option="" export menuentry_id_option menuentry 'CentOS Linux (4.9.0-rc8-amd64) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-4.9.0-rc8-amd64-advanced-508f0c60-8ce4-48fa-a00e-8db45fa56da8' &#123; menuentry 'CentOS Linux (3.10.0-327.36.3.el7.x86_64) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-3.10.0-327.36.3.el7.x86_64-advanced-508f0c60-8ce4-48fa-a00e-8db45fa56da8' &#123; menuentry 'CentOS Linux (0-rescue-d45b6a27fe9641bd8979101342a4f20b) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-0-rescue-d45b6a27fe9641bd8979101342a4f20b-advanced-508f0c60-8ce4-48fa-a00e-8db45fa56da8' &#123; # 下面命令的内核名称根据系统内部查到的实际名称来替换： grub2-set-default &#39;CentOS Linux (4.9.0-rc8-amd64) 7 (Core)&#39; grub2-editenv list saved_entry=CentOS Linux (4.9.0-rc8-amd64) 7 (Core)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>升级内核</tag>
        <tag>kernel</tag>
        <tag>bbr</tag>
        <tag>tcp_bbr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码与文件格式转换]]></title>
    <url>%2Flinux%2F%E7%BC%96%E7%A0%81%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[作用 在 windows 下使用 hexo 时，经常会出现 GBK 编码与 DOS 的问题 Windows 下自动将博客发布到 github 编码转换 “Trans_To_UTF-8.py” 12345678910111213141516171819202122232425262728# 请把以下脚本放至 /usr/local/bin/ 目录下import os,sysdef convert( filename, in_enc = "GBK", out_enc="UTF8" ): try: print "convert " + filename, content = open(filename).read() new_content = content.decode(in_enc).encode(out_enc) open(filename, 'w').write(new_content) print " done" except: print " error"def explore(dir): for root, dirs, files in os.walk(dir): for file in files: path = os.path.join(root, file) convert(path)def main(): for path in sys.argv[1:]: if os.path.isfile(path): convert(path) elif os.path.isdir(path): explore(path)if __name__ == "__main__": main() 准备脚本 “prepare.sh” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667POST_DIR="/cygdrive/e/blog/source/_posts"FBS_ESC=`echo -en "\033"`COLOR_RED="$&#123;FBS_ESC&#125;[1;31m" # ErrorCOLOR_GREEN="$&#123;FBS_ESC&#125;[1;32m"; # SuccessCOLOR_YELLOW="$&#123;FBS_ESC&#125;[1;33m" # WarningCOLOR_CLOSE="$&#123;FBS_ESC&#125;[0m" # Closecd $POST_DIRfor i in *; do if grep -q "author: dongcj &lt;ntwk@163.com&gt;" $i; then echo "$&#123;COLOR_GREEN&#125;SKIP$&#123;COLOR_CLOSE&#125;: filename: $i..." continue fi if file $i | grep -q "CRLF"; then # change to unix echo -n "$&#123;COLOR_YELLOW&#125;WARN$&#123;COLOR_CLOSE&#125;: filename: $i, coverting to unix.." dos2unix $i &amp;&amp; echo "done" || echo "$&#123;COLOR_RED&#125;failed$&#123;COLOR_CLOSE&#125;" fi if ! file $i | grep -q "UTF-8"; then # change to UTF-8 python /usr/local/bin/Trans_To_UTF-8.py $i &amp;&amp; echo "done" || echo "$&#123;COLOR_RED&#125;failed$&#123;COLOR_CLOSE&#125;" fi if ! ls $i | grep -q "\.md$"; then echo -n "$&#123;COLOR_YELLOW&#125;WARN$&#123;COLOR_CLOSE&#125;: filename: $i, renaming to $&#123;i%.*&#125;.md.." # rename suffix to ".md" mv $i $&#123;i%.*&#125;.md &amp;&amp; echo "done" || echo "$&#123;COLOR_RED&#125;failed$&#123;COLOR_CLOSE&#125;" else echo "filename: $i, skipped rename~" fi no_suffix_filename="$&#123;i%.*&#125;" # if does not have title if ! grep -q "title:" $i; then echo -n "$&#123;COLOR_YELLOW&#125;WARN$&#123;COLOR_CLOSE&#125;: filename: $i, adding title.." sed -i "1s/^/---\ntitle: $no_suffix_filename\n---\n/" $i echo "done" fi # zero title content title_content=`sed -n '/title: /p' $i | awk -F':' '&#123;print $NF&#125;' | xargs` if [ -z "$title_content" ]; then # update title when it is NULL echo -n "$&#123;COLOR_YELLOW&#125;WARN$&#123;COLOR_CLOSE&#125;: filename: $i, updating title.." sed -i "s/title: .*/title: $no_suffix_filename/" $i echo "done" else echo "filename: $i, skipped update~" fi # add author info if ! grep -q "author: dongcj &lt;ntwk@163.com&gt;" $i; then echo -n "$&#123;COLOR_YELLOW&#125;WARN$&#123;COLOR_CLOSE&#125;: filename: $i, updating author.." sed -i '/title: /a author: dongcj &lt;ntwk@163.com&gt;' $i echo "done" fi echodone Windows 下 &quot; 更新博客 .bat&quot; 12345REMcd "/cygdriver/d/blog"D:hexo g &amp;&amp; hexo decho "success"]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>utf-8</tag>
        <tag>编码</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐讯 K2 路由器刷机]]></title>
    <url>%2Flinux%2F%E6%96%90%E8%AE%AFK2%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[买个 SS 帐号 不要问我 SS 是什么，我只能告诉你它是现在最好的 fun 墙工具！一般 400 左右一年，但每个商家质量千差万别，买前最好问清楚有没有流量限制，可以用几台客户端等，最好有老司机带路。 路由刷机 路由器通电，网线一端连接 &quot; 自己电脑的网口 “，一头连接路由器的”LAN&quot; 口，注意：不是 WAN 口 查看自己电脑的 &quot; 网络连接 “，选中” 本地连接 “，点击右键，选择” 状态 &quot; -&gt; &quot; 详细信息 &quot; 查看自己的 IP 地址 自己电脑中打开浏览器：http://192.168.1.1 ( 一般是 192.168.1.1 这个 IP 地址，IP 前三位和 &quot; 本地连接 &quot; 中看到的 IP 一致，但最后一位修改为 1 ) 用户名和密码默认 “admin/admin” 登陆 WEB 后，点击菜单 &quot; 系统 &quot; -&gt; &quot; 升级 “( 其实我们是先降级，因为斐讯的默认系统是不让刷机的 )。然后浏览本地”breed_k2_163_v17_breed.bin&quot; 文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>刷机</tag>
        <tag>斐讯 K2</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Puppet 安装]]></title>
    <url>%2Flinux%2FPuppet%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[/etc/hosts 可以 ping 通对方域名 安装 puppet $ yum install ruby ruby-libs ruby-rdoc $ wget http://yum.puppetlabs.com/el/6/products/x86_64/puppetlabs-release-6-10.noarch.rpm ( 这个版本可以修改为最新的） $ yum update # 服务端安装 puppet-server $ yum install puppet-server # 服务端安装 puppet 图形界面（可选） $ yum install ruby-mysql mysql mod_passenger puppet-dashboard # 客户端安装 puppet $ yum install puppet service puppetmaster start $ puppet master --verbose --no-daemonize --cert_name &quot;Puppet CA: `hostname -f`&quot; $ openssl x509 -text -noout -in /var/lib/puppet/ssl/certs/ca.pem $ cat &gt; /etc/puppet/autosign.conf &lt;&lt;EOF *.xxx.com EOF $ service puppetmaster restart $ puppet cert list --all --&gt; 查看下证书，此时是没有客户机的，只有自己 在 /etc/puppet/puppet.conf 中添加 server = bigdata.xxxx.com 一行，为了方便命令都可以不用 --server bigdata.xxxx.com $ puppetd --server bigdata.xxxx.com --test 或者 $ puppet agent --no-daemonize --onetime --verbose --debug 安装 dashboard $ vi /usr/share/puppet-dashboard/config/database.yml production: database: puppet username: root password: passw0rd encoding: utf8 adapter: mysql $ vi /usr/share/puppet-dashboard/config/environment.rb config.time_zone = &#39;Beijing&#39; 初始化数据库 $ cd /usr/share/puppet-dashboard/ rake RAILS_ENV=production db:migrate 整合 Passenger 和 apache $ vi /etc/httpd/conf.d/passenger.conf LoadModule passenger_module modules/mod_passenger.so PassengerRoot /usr/lib/ruby/gems/1.8/gems/passenger-3.0.21 PassengerRuby /usr/bin/ruby PassengerHighPerformance on PassengerMaxPoolSize 12 PassengerPoolIdleTime 1500 PassengerStatThrottleRate 120 RailsAutoDetect On &lt;VirtualHost *&gt; ServerName bigdata.xxxx.com DocumentRoot &quot;/usr/share/puppet-dashboard/public/&quot; ErrorLog /var/log/httpd/puppet-dashboard_error.log LogLevel warn CustomLog /var/log/httpd/puppet-dashboard_access.log combined &lt;/VirtualHost&gt; 让 Dashboard 使用 Reports $ vi /etc/puppet/puppet.conf [master] reports = store, http reporturl = http://bigdata.xxxx.com:80/reports/upload 重启 puppetmaster 服务 $ /etc/init.d/puppetmaster restart 导入报告 $ cd /usr/share/puppet-dashboard $ rake RAILS_ENV=production reports:import 执行导入的 reports $ rake jobs:work RAILS_ENV=&quot;production&quot; 下载及文档地址 http://code.google.com/p/puppet-manifest-share/downloads/list http://www.vpsee.com/2012/03/install-puppet-on-centos-6-2/ http://dongxicheng.org/cluster-managemant/puppet/]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>puppet</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postgresql 主从配置]]></title>
    <url>%2Fdatabase%2FPostgresql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装好二台 postgresql 参见：http://blog.dongcj.com/database/Postgresql%E5%AE%89%E8%A3%85/ 12345678910# 主服务器上vi /etc/profile export PGDATA=/pgdatasource /etc/profilevi /etc/profile export PGDATA=/pgdata_backupsource /etc/profile 配置主服务器 192.168.10.11 1234567891011121314151617181920212223242526# 使用 root 帐户mkdir /pgdatachown -R postgres:postgres /pgdata/su - postgrespsql [ -p 54321 ] # 如果修改过端口，需要指定端口psql$ CREATE ROLE replica login replication encrypted password 'replica';# 增加 replica 用户cd /pgdatavi pg_hba.conf host replication replica 192.168.10.12/32 md5# 配置复制参数vi postgresql.conf wal_level = hot_standby # 主为 wal 的主机 max_wal_senders = 32 # 最多几个流复制 wal_keep_segments = 256 # 设置流复制保留最多的 log 数目，每个 log 16M wal_sender_timeout = 60s # 流复制主机发送数据的超时时间 max_connections = 100 # 注意：从库的 max_connections 必须要大于主库的# 修改权限chmod -R 700 /pgdata/# 重启 pgpg_ctl restart 配置从服务器 192.168.10.12 1234567891011121314151617181920212223242526272829# 使用 root 帐户mkdir /pgdata_backupchown -R postgres:postgres /pgdata_backup/su - postgrespg_basebackup -F p --progress -D /pgdata_backup -h 192.168.10.11 -p 5432 -U replica --password# password is: replicacd /pgdata_backup# 编辑配置vi recovery.conf# 如果找不到 recovery.conf，可以新建，只需要下面三行即可recovery_target_timeline = 'latest'standby_mode = onprimary_conninfo = 'host=192.168.10.11 port=5432 user=replica password=replica'# 编辑配置vi postgresql.confmax_connections = 1000 # ( 要大于主库的 )hot_standby = on # 说明这台机器不仅仅是用于数据归档，也用于数据查询max_standby_streaming_delay = 30s # 多久向主报告一次从的状态，最长的间隔时间wal_receiver_status_interval = 5s # 间隔多久将状态信息发送给主hot_standby_feedback = on # 如果有错误的数据复制，是否向主进行反馈chmod -R 700 /pgdata_backup/# 启动从 pgpg_ctl start # 在主上应该有 sender 进程，在从上有 receiver 进程 $ psql$ select * from pg_stat_replication; 主从切换命令 [postgres@node1 ~]$ pg_ctl stop -m f [postgres@node2 ~]$ pg_ctl promote [postgres@node2 ~]$ createdb pgbench [postgres@node2 ~]$ pgbench -i -s 10 pgbench node1 将以前 master 恢复为 standby pg_rewind -D /opt/pgsql/data/ –source-server=‘host=node2 user=postgres port=5432’ vi /opt/pgsql/data/recovery.conf standby_mode = ‘on’ primary_conninfo = ‘host=node2 user=postgres port=5432’ recovery_target_timeline = ‘latest’ 启动 node1 上的数据库： [postgres@node1 ~]$ pg_ctl start 将 node1 恢复为 master [postgres@node2 ~]$ pg_ctl stop -m f [postgres@node1 ~]$ pg_ctl promote [postgres@node1 ~]$ pgbench -s 10 -T 60 pgbench [postgres@node2 ~]$ pg_rewind -D /opt/pgsql/data/ –source-server=‘host=node1 user=postgres port=5432’ [postgres@node2 ~]$ mv /opt/pgsql/data/recovery.done /opt/pgsql/data/recovery.conf 修改 node2 为 node1 vi /opt/pgsql/data/recovery.conf 启动 node2 上的数据库： [postgres@node2 ~]$ pg_ctl start ```]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
        <tag>pg recovery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PXE 安装与设定]]></title>
    <url>%2Flinux%2FPXE%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[安装软件 # 安装的软件： dhcp-3.0.5-7.el5.x86_64.rpm vsftpd-2.0.5-10.el5.x86_64.rpm( 不须装 ) xinetd-2.3.14-10.el5.x86_64.rpm tftp-server-0.42-3.1.x86_64.rpm pykickstart-0.43.3-1.el5.noarch.rpm system-config-kickstart-2.6.19.1-1.el5.noarch.rpm syslinux # 关闭 selinux &amp; iptables dhcp 配置 ddns-update-style interim; ignore client-updates; allow booting; allow bootp; class &quot;pxeclients&quot;{ match if substring(option vendor-class-identifier,0,9) = &quot;PXEClient&quot;; filename &quot;/pxelinux.0&quot;; next-server 10.85.138.9; } subnet 10.85.138.0 netmask 255.255.254.0 { option routers 10.85.138.1; option subnet-mask 255.255.254.0; option domain-name &quot;gwcloud.com&quot;; option domain-name-servers 10.85.138.1; option time-offset -18000; # Eastern Standard Time range dynamic-bootp 10.85.138.100 10.85.138.249; default-lease-time 21600; max-lease-time 43200; } 增加 tftp 文件 拷文件至 tftpboot( 注：menu.c32 和 pxelinux.0 要从本机拷贝，否则 TIMEOUT 无效！ ) $ cp /usr/share/syslinux/menu.c32 /var/lib/tftpboot/ $ cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/ $ cp /mnt/isolinux/initrd.img /var/lib/tftpboot/isolinux $ cp /mnt/isolinux/vmlinuz /var/lib/tftpboot/isolinux $ cp /mnt/isolinux/isolinux.cfg /tftpboot/pxelinux.cfg/default # default 文件也可以自己修改 配置 kickstart # 在 /tftpboot/pxelinux.cfg/default 中添加 KS 入口 label linux menu label ^Install or upgrade an existing system menu default kernel vmlinuz append initrd=isolinux/initrd.img ks=ftp://10.85.138.9/pub/ks.cfg # 修改 kickstart 自动安装 linux( 见安装文件 ) 附录：完整 DHCP 样例 ddns-update-style interim; ddns-updates on; ignore client-updates; allow booting; # for pxe only allow bootp; # for pxe only authoritative; # Do not know what is meaning?? class &quot;pxeclients&quot;{ match if substring(option vendor-class-identifier,0,9) = &quot;PXEClient&quot;; # for pxe # match if substring(option vendor-class-identifier, 0, 4) = &quot;MSFT&quot;; # for normal dhcp # option host-name = config-option server.ddns-hostname; # set the server&#39;s hostname, only for linux??? ddns-hostname = concat(&quot;v&quot;, suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 1, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 2, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 3, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 4, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 5, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 6, 1))), 2) ); filename &quot;/pxelinux.0&quot;; # for pxe only next-server 192.168.88.1; # for pxe only } class &quot;MSFT&quot; { match if substring(option vendor-class-identifier, 0, 4) = &quot;MSFT&quot;; option host-name = config-option server.ddns-hostname; #ddns-hostname = concat(&quot;v&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 1, 6))); #ddns-hostname = pick (option host-name, concat(&quot;v&quot;, # Windows instances will apply for a hostname by default ddns-hostname = concat(&quot;v&quot;, suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 1, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 2, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 3, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 4, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 5, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 6, 1))), 2) ); } option host-name = config-option server.ddns-hostname; ddns-hostname = pick (option host-name, concat(&quot;v&quot;, suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 1, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 2, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 3, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 4, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 5, 1))), 2), suffix(concat(&quot;0&quot;, binary-to-ascii(16, 8, &quot;&quot;, substring (hardware, 6, 1))), 2) )); set vendor-string = option vendor-class-identifier; subnet 192.168.88.0 netmask 255.255.255.0 { option routers 192.168.88.1; option subnet-mask 255.255.255.0; option domain-name &quot;gwcloud.cn&quot;; option domain-name-servers 192.168.88.1; # option host-name &quot;Server001&quot; # set the server&#39;s hostname, only for linux??? # option ntp-servers 192.168.88.1 # set the ntp server option time-offset -18000; # Eastern Standard Time range dynamic-bootp 192.168.88.100 192.168.88.200; default-lease-time 21600; max-lease-time 43200; # the next is bonding the mac to static ip address # host pc1 { # hardware ethernet 00:a0:cc:cf:9C:14; # host&#39;s mac address # fixed-address 192.168.1.30; # host&#39;s ip address }]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>dhcp</tag>
        <tag>pxe</tag>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graphite 安装]]></title>
    <url>%2Fmonitor%2FGraphite%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[参考： http://www.jsxubar.info/category/system-administration/graphite/ http://www.jsxubar.info/category/system-administration/page/3/ http://dongweiming.github.io/blog/archives/shi-yong-grafanahe-diamondgou-jian-graphitejian-kong-xi-tong/ 使用 yum 安装环境 $ yum install bitmap bitmap-fonts Django pycairo python-devel python-ldap python-memcached mod_wsgi python-sqlite2 glibc-devel gcc gcc-c++ git openssl-devel python-zope-interface httpd memcached python-hashlib django-tagging python-twisted python-simplejson httpd mod_wsgi $ pip install whisper $ pip install carbon $ pip install graphite-web 安装并升级为最新的 zope.interface 及 twisted # ( 确保这个版本要到 3.6.0 以上，如果不行，下载安装 ) 及 twisted $ wget https://pypi.python.org/simple/zope.interface/zope.interface-4.1.2-py2.6-win-amd64.egg $ easy_install zope.interface-4.1.2-py2.6-win-amd64.egg # test twisted [root@bigdata twisted]# python Python 2.6.6 (r266:84292, Jan 22 2014, 09:42:36) [GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux2 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; from twisted.python.compat import _PY3 &gt;&gt;&gt; Check for missing dependencies $ python /tmp/pip-build-me/graphite-web/check-dependencies.py 设置权限 $ chown -R apache:apache /opt/graphite/storage/ 配置文件 $ cp /opt/graphite/webapp/graphite/local_settings.py.example /opt/graphite/webapp/graphite/local_settings.py $ cp /opt/graphite/conf/carbon.conf.example /opt/graphite/conf/carbon.conf $ cp /opt/graphite/conf/storage-schemas.conf.example /opt/graphite/conf/storage-schemas.conf # 如果需要用其它数据库，请修改 /opt/graphite/webapp/graphite/local_settings.py $ python /opt/graphite/webapp/graphite/manage.py syncdb $ cd /opt/graphite/conf/ $ cp graphite.wsgi.example graphite.wsgi $ cp storage-schemas.conf.example storage-schemas.conf $ cp carbon.conf.example carbon.conf $ cd /opt/graphite/webapp/graphite $ cp local_settings.py.example local_settings.py 在 httpd 中启用 virtualHost $ cd ../../ $ cp examples/example-graphite-vhost.conf /etc/httpd/conf.d/vhost-graphite.conf $ vi /etc/httpd/conf.d/vhost-graphite.conf WSGISocketPrefix /var/run/httpd/wsgi 修改已知的 bug $ vi /opt/graphite/webapp/graphite/storage.py def fetch(self, startTime, endTime, now=None): return whisper.fetch(self.fs_path, startTime, endTime) # 去掉最后一个 now graph-index-master graphite-web-master]]></content>
      <categories>
        <category>monitor</category>
      </categories>
      <tags>
        <tag>graphite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gearman 安装]]></title>
    <url>%2Fcluster%2FGearman%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[参考 http://www.php-oa.com/2010/09/05/perl-gearman-distributed.html python gearman library home page http://samuelks.com/python-gearman/docs/ Tim Yang：利用 Gearman 来实现远程监控与管理 http://timyang.net/linux/gearman-monitor/ 一、安装 grarmand 及 libgearman-devel $ yum install gearmand libgearman-devel php-pecl-gearman ( 直接安装这个 php-pecl-gearman 就不用第二步：安装 PHP 的 API 了 ) 二、安装 PHP 的 API $ yum install php php-devel boost boost-devel libuuid libuuid-devel $ tar -xzf gearman-1.1.2.tgz # 下载地址：https://pecl.php.net/package/gearman $ cd gearman-1.1.2 $ phpize $ ./configure; make; make install // 实际上是给 PHP 增加了个 gearman 的 extension: /usr/lib64/php/modules/gearman.so # 增加 php 扩展 $ vi /etc/php.d/gearman.ini ; Enable gearman extension module extension=gearman.so 三、启动 gearmand # ( 如果使用默认参数，需要开启 IPV6) # 可以设置成服务启动： $ vi /etc/sysconfig/gearmand OPTIONS=&quot;-L 0.0.0.0 --verbose=DEBUG&quot; --&gt; 根据自己需求设置 --verbose $ service gearmand start $ gearmand -d --http-port 8090 -L 0.0.0.0 -p 4730 # 如果需要使用数据库 gearmand -d --http-port=8080 -L 0.0.0.0 -p 4730 --mysql-user=root --mysql-password=YOUR_PASS --mysql-db gearman $ gearman -w -f wc -- wc -l // 开启一个 worker（-w）, 监听一个函数 wc(-f wc)， 函数的内容为 wc -l # 将 /etc/passwd 文件给函数 wc 进行处理 $ gearman -f wc &lt; /etc/passwd $ gearadmin --show-jobs --status --workers -- ... 1. Worker: &lt;?php $worker = new GearmanWorker(); $worker-&gt;addServer(); $worker-&gt;addFunction(&quot;reverse&quot;, &quot;reverse_fn&quot;); while (1) { print &quot;Waiting for job...\n&quot;; $ret = $worker-&gt;work(); if($worker-&gt;returnCode() != GEARMAN_SUCCESS) { break; } } function reverse_fn(GearmanJob $job) { $workload = $job-&gt;workload(); echo &quot;Received job: &quot;. $job-&gt;handle(). &quot;\n&quot;; echo &quot;Workload: $workload\n&quot;; $result = strrev($workload); echo &quot;Result: $result\n&quot;; return $result; } ?&gt; 2. client: &lt;?php $client = new GearmanClient(); $client-&gt;addServer(); echo &quot;sending job\n&quot;; if($result) { echo &quot;Success: $result\n&quot;; } else { echo &quot;Failed!&quot;; } ?&gt;]]></content>
      <categories>
        <category>cluster</category>
      </categories>
      <tags>
        <tag>gearman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GlusterFS 安装]]></title>
    <url>%2Fstorage%2FGlusterFS%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[参考： https://wiki.centos.org/zh/HowTos/GlusterFSonCentOS $ wget -P /etc/yum.repos.d http://download.gluster.org/pub/gluster/glusterfs/LATEST/EPEL.repo/glusterfs-epel.repo 安装软件 yum install glusterfs{,-fuse,-server} yum install glusterfs-geo-replication.x86_64 如遇到以下错误： Transaction check error: file /usr/lib/systemd/system/blk-availability.service from install of device-mapper-7:1.02.107-5.el7_2.2.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64 file /usr/sbin/blkdeactivate from install of device-mapper-7:1.02.107-5.el7_2.2.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64 file /usr/share/man/man8/blkdeactivate.8.gz from install of device-mapper-7:1.02.107-5.el7_2.2.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64 # 删除 lvm2 $ rpm -e lvm2 挂载分区及配置防火墙 # mkdir $ mkdir /export/brick1 # 这里可以修改权限 , 其它程序可以使用， 注意所有服务器上都要修改！！！ $ chmod 777 /export/brick1 # firewall $ firewall-cmd --zone=public --add-port=24007-24008/tcp --permanent $ firewall-cmd --zone=public --add-service=nfs --add-service=samba --add-service=samba-client --permanent $ firewall-cmd --zone=public --add-port=111/tcp --add-port=139/tcp --add-port=445/tcp --add-port=965/tcp --add-port=2049/tcp \ --add-port=38465-38469/tcp --add-port=631/tcp --add-port=111/udp --add-port=963/udp --add-port=49152-49251/tcp --permanent $ firewall-cmd --reload 启动 glusterd 服务 $ service glusterd start # if centos7: $ systemctl enable glusterd $ systemctl start glusterd $ systemctl status glusterd # from server1 $ gluster peer probe SERVER2 # from server2 $ gluster peer probe SERVER1 # check peer $ gluster peer status $ gluster volume create gv0 replica 2 HOSTNAME_OF_SERVER1:/export/brick1/gv0 HOSTNAME_OF_SERVER2:/export/brick1/gv0 $ gluster volume start gv0 $ gluster volume info $ gluster volume status # How to remove a volume or peer # stop Volume $ gluster volume stop gv0 # delete Volume $ gluster volume delete gv0 $ gluster peer detach NAME_OF_PEERNODE Test Gluster volume # mount to /mnt $ mount -t glusterfs node01.yourdomain.net:/gv0 /mnt $ vi /etc/fstab gluster1.example.com:/gv0 /mnt/glusterfs glusterfs defaults,_netdev 0 0 # 如果使用 nfs 协议使用 # GlusterFS NFS 服务器只支持第 3 版的 NFS 沟通协议。 $ vi /etc/nfsmount.conf Defaultvers=3 $ systemctl restart glusterd.service # start force $ gluster volume set gv0 nfs.disable off $ gluster volume start gv0 force $ mount -t nfs PEER_NODE:/gv0 /mnt/glusterfs 配置 Quorum() ...... 参考 : https://wiki.centos.org/zh/HowTos/GlusterFSonCentOS]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>gluster</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP 高级配置]]></title>
    <url>%2Flinux%2FDHCP%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[# 一、DHCP 中继代理配置 # ( 在其它服务上安装 dhcpd 软件 )： $ vi /etc/sysconfig/dhcrelay # Command line options here INTERFACES=&quot;eth1 eth2&quot; DHCPSERVERS=&quot;192.168.1.1&quot; # 也可以通过以下命令方式来实现： $ dhcrelay -i eth1 -i eth2 192.168.1.1 # 二、DHCP 超网配置 ddns-update-style interim; /*dhcp 支持的 dns 动态更新方式*/ ignore client-updates; /*忽略客户端 DNS 动态更新*/ shared-network mynet { /*超网作用域选项，共同部分*/ option subnet-mask 255.255.255.0; /*子网掩码*/ option domain-name &quot;koumm.net&quot;; /*域名*/ option domain-name-servers 192.168.1.2; /*dns IP*/ option broadcast-address 192.168.1.255; /*广播地址*/ default-lease-time 86400; /*租期 1 天，秒数*/ max-lease-time 172800; /*最长租期 2 天*/ subnet 192.168.1.0 netmask 255.255.255.0 { /*1.0 子网段*/ range 192.168.1.11 192.168.1.100; /*ip 地址段范围*/ option routers 192.168.1.1; /*网关地址*/ /*绑定 pc1 主机 ip 地址配置*/ host pc1 { hardware ethernet 00:a0:cc:cf:9C:14; fixed-address 192.168.1.20; } /*绑定 pc2 主机 ip 地址配置*/ host pc2 { hardware ethernet 04:20:c1:f8:37:11; fixed-address 192.168.1.30; } } subnet 192.168.2.0 netmask 255.255.255.0 { /*2.0 子网段*/ range 192.168.2.10 192.168.2.100; /*ip 地址段范围*/ option routers 192.168.2.1; /*网关地址*/ } subnet 192.168.3.0 netmask 255.255.255.0 { /*3.0 子网段*/ range 192.168.3.10 192.168.3.100; /*ip 地址段范围*/ option routers 192.168.3.1; /*网关地址*/ } }]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>dhcp</tag>
        <tag>pxe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Curl、resty、httpie、httpstat、wuzz 使用介绍]]></title>
    <url>%2Flinux%2FCurl%E3%80%81resty%E3%80%81httpie%E3%80%81httpstat%E3%80%81wuzz%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[curl 下载文件 123456export DOCKERIZE_VERION=latest &amp;&amp; \export DOCKERIZE_ARCH=dockerize-linux-amd64DOCKERIZE_DOWNLOADURL=$(curl -s https://api.github.com/repos/jwilder/dockerize/releases/$&#123;DOCKERIZE_VERION&#125; | jq -r ".assets[] | select(.name | test(\"$&#123;DOCKERIZE_ARCH&#125;\")) | .browser_download_url")curl -sSOL http://$DOCKERIZE_DOWNLOADURL# or curl -sSL $&#123;DOCKERIZE_DOWNLOADURL&#125; | tar zxvf - -C $&#123;MODULE_HOME&#125; 详细信息 curl -v www.sina.com curl --trace output.txt www.sina.com curl --trace-ascii output.txt www.sina.com curl -s --head www.sina.com 上传文件 curl --form upload=@localfilename --form press=OK [URL] curl -T file.txt curl --cookie &quot;name=xxx&quot; www.example.com curl --user name@DOMAIN:password http://example.com curl -fsSL ... 下载网页保存为文件名 curl -o [文件名] www.sina.com curl -L www.sina.com curl --limit-rate 1000B -O http://www.gnu.org/software/gettext/manual/gettext.html 对于 https 的方法，添加 –insecure curl --insecure -LJO https://packages.gitlab.com/gitlab curl example.com/form.cgi?data=xxx 增加头信息 (-H) curl -i -X GET --header &quot;Content-Type:application/json&quot; http://example.com # 模拟服务地址（例如有些网站只能用域名访问的） curl – H Host:web-test.proxy-test.local http://192.168.1.2:8080 POST：(-d) curl -i -X POST --data &quot;data=xxx&quot; example.com/form.cgi curl -i -X POST --data-urlencode &quot;date=April 1&quot; example.com/form.cgi Referer(-e) curl --referer http://www.example.com http://www.example.com User Agent 字段 (-A) curl --user-agent &quot;[User Agent]&quot; http://www.example.com 配置压缩 (-I means “Fetch the HTTP-header only”) curl -I http://www.111cn.net/ -H Accept-Encoding:gzip,defaltefrom 超时设置 --connect-timeout 3 # 3 秒连接时间 -m | --max-time 5 # 连接 5 秒后自动断开 本地 socket curl --unix-socket /var/run/docker.sock http:/images/json or curl --unix-socket /var/run/docker.sock http://localhost/images/json curl examples # zabbix 使用 API 进行认证 # curl -i -X POST -H &#39;Content-Type:application/json&#39; -d &#39;{&quot;jsonrpc&quot;: &quot;2.0&quot;,&quot;method&quot;:&quot;user.authenticate&quot;,&quot;params&quot;:{&quot;user&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;passw0rd&quot;},&quot;auth&quot;: null,&quot;id&quot;:0}&#39; http://192.168.0.54/api_jsonrpc.php HTTP/1.1 200 OK Date: Mon, 12 Aug 2013 05:53:05 GMT Server: Apache/2.2.21 (Linux/SUSE) X-Powered-By: PHP/5.3.8 Content-Length: 68 Content-Type: application/json {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;c12f74265ea3cfb772b5e1d56957645b&quot;,&quot;id&quot;:0} # zabbix 利用 tokern 和 id 进行注册主机 2. echo `cat /tmp/123.txt` --- 这样也可以 ... 3. curl -i -X POST -H &#39;Content-Type: application/json&#39; -d &#39; 格式化后的内容 &#39; http://192.168.0.54/api_jsonrpc.php -i|--include : 在输出中包含 HTTP 头 ( 如服务器名，日期，HTTP 版本等 ) -s|--silent : 静默模式 -X|--request : 请求 HTTP 服务，默认为 GET resty 模拟请求 # install resty curl -L http://github.com/micha/resty/raw/master/resty &gt; resty # 导入变量 . resty $ resty http://127.0.0.1:8080/data http://127.0.0.1:8080/data* $ GET /blogs.json [ {&quot;id&quot; : 1, &quot;title&quot; : &quot;first post&quot;, &quot;body&quot; : &quot;This is the first post&quot;}, ... ] $ PUT /blogs/2.json &#39;{&quot;id&quot; : 2, &quot;title&quot; : &quot;updated post&quot;, &quot;body&quot; : &quot;This is the new.&quot;}&#39; {&quot;id&quot; : 2, &quot;title&quot; : &quot;updated post&quot;, &quot;body&quot; : &quot;This is the new.&quot;} $ DELETE /blogs/2 $ POST /blogs.json &#39;{&quot;title&quot; : &quot;new post&quot;, &quot;body&quot; : &quot;This is the new new.&quot;}&#39; {&quot;id&quot; : 204, &quot;title&quot; : &quot;new post&quot;, &quot;body&quot; : &quot;This is the new new.&quot;} 使用 httpie # install $ apt-get install httpie # usage $http httpie.org $ http PUT example.org X-API-Token:123 name=John $ http -f POST example.org hello=World $ http -v example.org $ http -a USERNAME POST https://api.github.com/repos/jakubroztocil/httpie/issues/83/comments body=&#39;HTTPie is awesome! :heart:&#39; $ http example.org &lt; file.json $ http example.org/file &gt; file $ http --download example.org/file $ http --session=logged-in -a username:password httpbin.org/get API-Key:123 $ http --session=logged-in httpbin.org/headers $ http localhost:8000 Host:example.com $ http DELETE example.org/todos/7 httpstat httpstat wuzz wuzz]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>resty</tag>
        <tag>httpie</tag>
        <tag>httpstat</tag>
        <tag>wizz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 及 Upstreamcheck,fair 模块安装]]></title>
    <url>%2Fweb%2FNginx%E5%8F%8Aupstreamcheck%2Cfair%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[download nginx &amp; module 123456789101112cd /tmp# main softwarewget http://nginx.org/download/nginx-1.11.5.tar.gz# dependency(if necessary)wget https://nchc.dl.sourceforge.net/project/pcre/pcre/8.41/pcre-8.41.tar.gz# module nginx_upstream_check_modulegit clone https://github.com/yaoweibin/nginx_upstream_check_module.git# module nginx-upstream-fairgit clone https://github.com/gnosek/nginx-upstream-fair.git make &amp; install 12345678910111213141516# install dependency(if necessary)tar xzf pcre-8.41.tar.gzcd pcre-8.41./configuremake &amp;&amp; make installldconfig# install nginxtar xzf nginx-1.11.5.tar.gzcd nginx-1.11.5./configure --user=nobody --group=nobody --prefix=/usr/local/nginx/ \--with-http_stub_status_module \--add-module=../nginx_upstream_check_module \--add-module=../nginx-upstream-fairmake &amp;&amp; make install nginx.conf &amp; proxy.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105vi /usr/local/nginx/conf/nginx.confuser nobody;worker_processes 4;# security# server_tokens off;# proxy_hide_header X-Powered-By;error_log /var/log/nginx/error.log warn;#error_log /var/log/nginx/error.log notice;#error_log /var/log/nginx/error.log debug;pid /var/run/nginx.pid;events &#123; worker_connections 8192;&#125;http &#123; include /usr/local/nginx/conf/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; # 设定负载均衡的服务器列表 upstream lb.xxx.com &#123; server xxxx:8088; server xxxx:8088; # upstream check check interval=6000 rise=1 fall=3 timeout=4000; # fairly scheduler fair; &#125; # fastcgi config fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; # gzip config gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; server &#123; listen 80; include proxy.conf; # check_status_module # usage: curl http://localhost/status?format=json # 好像无法生效 location /status?format=json &#123; check_status; access_log off; allow 127.0.0.1; deny all; &#125; # http_stub_status location /ng_status &#123; stub_status on; access_log off; allow 127.0.0.1; deny all; &#125; # upstream location / &#123; proxy_pass http://lb.xxx.com; &#125; # static file expires location ~ .*\.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)($|/) &#123; expires 30d; &#125; # js &amp; css expires location ~ .*\.(js|css)($|/) &#123; expires 8h; &#125; &#125;&#125; 123456789101112131415vi /usr/local/nginx/conf/proxy.confproxy_redirect off;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;client_max_body_size 10m;client_body_buffer_size 128k;proxy_connect_timeout 90;proxy_send_timeout 90;proxy_read_timeout 90;proxy_buffer_size 4k;proxy_buffers 4 32k;proxy_busy_buffers_size 64k;proxy_temp_file_write_size 64k; start &amp; auto-start 12345678910# autostartecho "/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf" &gt;&gt;/etc/rc.local# make log dirmkdir -p /var/log/nginx/# start/etc/rc.local# stoppkill nginx# reloadnginx -s reload]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>upstreamcheck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mdadm_raid10_raid5]]></title>
    <url>%2Flinux%2FMdadm_raid10_raid5%2F</url>
    <content type="text"><![CDATA[每块硬盘分一个区 # 分区格式为 Linux software raid： $ fdisk /dev/sda WARNING: DOS-compatible mode is deprecated. It&#39;s strongly recommended to switch off the mode (command &#39;c&#39;) and change display units to sectors (command &#39;u&#39;). Command (m for help): n Command action e extended p primary partition (1-4) p Partition number (1-4): 1 First cylinder (1-91201, default 1): Using default value 1 Last cylinder, +cylinders or +size{K,M,G} (1-91201, default 91201): Using default value 91201 Command (m for help): p Disk /dev/sda: 750.2 GB, 750156374016 bytes 255 heads, 63 sectors/track, 91201 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x0005c259 Device Boot Start End Blocks Id System /dev/sda1 1 91201 732572001 83 Linux Command (m for help): t Selected partition 1 Hex code (type L to list codes): fd Changed system type of partition 1 to fd (Linux raid autodetect) Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. Syncing disks. 更改分区格式 # 按照上面的 /dev/sda 的分区例子依次给剩下的 5 块硬盘 sdc, sdd, sde, sdf, sdg 分区 $ fdisk /dev/sdc ... $ fdisk /dev/sdd ... $ fdisk /dev/sde ... $ fdisk /dev/sdf ... $ fdisk /dev/sdg ... 创建 RAID # 在上面的 6 个相同大小的分区上创建 raid10 $ mdadm --create /dev/md0 -v --raid-devices=6 --level=raid10 /dev/sda1 /dev/sdc1 /dev/sdd1 /dev/sde1 /dev/sdf1 /dev/sdg1 mdadm: layout defaults to n2 mdadm: layout defaults to n2 mdadm: chunk size defaults to 512K mdadm: size set to 732440576K mdadm: Defaulting to version 1.2 metadata mdadm: array /dev/md0 started. # 查看磁盘阵列的初始化过程（build），根据磁盘大小和速度，整个过程大概需要几个小时： # watch cat /proc/mdstat Every 2.0s: cat /proc/mdstat Tue Feb 11 12:51:25 2014 Personalities : [raid10] md0 : active raid10 sdg1[5] sdf1[4] sde1[3] sdd1[2] sdc1[1] sda1[0] 2197321728 blocks super 1.2 512K chunks 2 near-copies [6/6] [UUUUUU] [&gt;....................] resync = 0.2% (5826816/2197321728) finish=278.9min speed=13 0948K/sec unused devices: $ fdisk /dev/md0 $ mkfs.ext4 /dev/md0p1 $ mkdir /raid10 $ mount /dev/md0p1 /raid10 $ vi /etc/fstab ... /dev/md0p1 /raid10 ext4 noatime,rw 0 0 $ blkid ... /dev/md0p1: UUID=&quot;093e0605-1fa2-4279-99b2-746c70b78f1b&quot; TYPE=&quot;ext4&quot; $ vi /etc/fstab ... /dev/md0p1 /raid10 ext4 noatime,rw 0 0 **UUID=093e0605-1fa2-4279-99b2-746c70b78f1b /raid10 ext4 noatime,rw 0 0** $ mdadm --query --detail /dev/md0 /dev/md0: Version : 1.2 Creation Time : Tue Feb 11 12:50:38 2014 Raid Level : raid10 Array Size : 2197321728 (2095.53 GiB 2250.06 GB) Used Dev Size : 732440576 (698.51 GiB 750.02 GB) Raid Devices : 6 Total Devices : 6 Persistence : Superblock is persistent Update Time : Tue Feb 11 18:48:10 2014 State : clean Active Devices : 6 Working Devices : 6 Failed Devices : 0 Spare Devices : 0 Layout : near=2 Chunk Size : 512K Name : local:0 (local to host local) UUID : e3044b6c:5ab972ea:8e742b70:3f766a11 Events : 70 Number Major Minor RaidDevice State 0 8 1 0 active sync /dev/sda1 1 8 33 1 active sync /dev/sdc1 2 8 49 2 active sync /dev/sdd1 3 8 65 3 active sync /dev/sde1 4 8 81 4 active sync /dev/sdf1 5 8 97 5 active sync /dev/sdg1 $ echo device /dev/sdb1 /dev/sdc1 /dev/sdd1 &gt; /etc/mdadm.conf $ mdadm --detail --scan &gt;&gt; /etc/mdadm.conf RAID 维护命令 删除故障盘 $ mdadm /dev/md0 -r /dev/sdb1 增加新盘 $ mdadm /dev/md0 -a /dev/sde1 $ mdadm --stop /dev/md99 // 停止 $ mdadm -As /dev/md0 // 启动 $ mdadm --remove /dev/md99 mdadm --manage /dev/md99 --fail /dev/sd[cde]1 mdadm --manage /dev/md99 --remove /dev/sd[cde]1 mdadm --manage /dev/md99 --stop mdadm --zero-superblock /dev/sd[cde]1]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>soft raid</tag>
        <tag>mdadm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox 报错 E_FAIL0x80004005 解决方案]]></title>
    <url>%2Flinux%2FVirtualBox%E6%8A%A5%E9%94%99E_FAIL0x80004005%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[VirtualBox 4.3.12 后的版本才会有 E_FAIL (0x80004005) 问题 返回 代码 : E_FAIL (0x80004005) 组件 : MachineWrap 界面 : IMachine {f30138d4-e5ea-4b3a-8858-a059de4c93fd} 寻找原因 直到最近重装系统，我才找到了问题的原因—— MacType。 是的，MacType 与 VirtualBox（4.3.14 以上版本）冲突。 尽管这并不是真正底层的原因，因为同样类似的问题发生了在了很多外国人身上，我相信他们中很多是不用 MacType 的，但我还是因为 MacType 找到了我自己在这个问题上的解决方案。 解决方案 在 MacType 的配置文件中排除 VirtualBox 的进程即可。 123[ExcludeModule]VBoxSVC.exeVirtualBox.exe 鼠标点击 VM 窗口底部图标会导致的 0x00000000 内存不能为 written 1sfc /scannow 还是不行的话，有可能是你的主题 (theme) 被替换过，使用工具 UniversalThemePatcher 恢复下就好 通过 google 搜索居然解决这种多年顽疾有多么喜悦是很难让外人理解的，但我真的非常开心 ~ 参考：https://donneryst.com/blog/virtualbox-4-3-12%E4%BB%A5%E5%90%8E%E7%9A%84e_fail-0x80004005%E9%97%AE%E9%A2%98.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>virtualbox</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parted,kpartx,losetup,sfdisk,e2fsck,resize2fs]]></title>
    <url>%2Flinux%2FParted%2Ckpartx%2Closetup%2Csfdisk%2Ce2fsck%2Cresize2fs%2F</url>
    <content type="text"><![CDATA[虚拟机增加系统盘根分区大小方法 # 此方法适用于分区后连接的空间 , 如果是 swap, 将其删除，并在最末尾建 swap ) # 先增加实例文件大小，可以使用 dd 命令 $ dd if=/dev/zero of=/tmp/temp_expand bs=1M count=4096（增加 4 GB） $ cat /tmp/temp_expand &gt;&gt;/var/lib/libvirt/images/my_vm.img # 挂载文件至系统，以便找出是否有 swap device $ kpartx -a -p p /var/lib/libvirt/images/my_vm.img # If has swap device, del the swap device $ swapDevice=`sfdisk -s -l /dev/loop0 | grep -e &#39;Linux swap&#39; |awk &#39;{print $1}&#39;` # Del swap $ parted -s ${loop} rm ${swap_part_num} # If does&#39;t have, add the new swap device $ parted -s /dev/loop1 &quot;unit mb mkpart primary linux-swap -2048MB -0&quot; # 或者先只划分空间，再用 mkswap 进行操作 # 可选的： $ mkswap -v1 /dev/mapper/loop1p3 # 重新刷新新增加的 swap 设备 $ kpartx -d -p p /var/lib/libvirt/images/my_vm.img $ kpartx -a -p p /var/lib/libvirt/images/my_vm.img # 将新的 lo 设备分区进行打印 $ sfdisk -d /dev/loop0 &gt;/tmp/sfdisk_dump # 如果有 swap 分区，则 root 分区为 (root start), (swap start - root start)；如果没有 , 则为 (root start), new_root=401625,14227239 ( 样例，要修改 ) converted_root_device=`echo &quot;/dev/loop0p1&quot; | sed -e &#39;s/\//\\\\\//g&#39;` $ sed -e &quot;s/^${converted_root_device}.*$/$new_root/&quot; /tmp/sfdisk_dump | sfdisk --no-reread --force /dev/loop1 # 重新刷新新变更的分区 $ kpartx -d -p p /var/lib/libvirt/images/my_vm.img $ kpartx -a -p p /var/lib/libvirt/images/my_vm.img # fs resize $ e2fsck -pv /dev/mapper/loop0p1 $ resize2fs -f /dev/mapper/loop0p1 parted 使用 # create all 100% space to one part $ parted -s /dev/sdb mklabel gpt $ parted -a optimal -s /dev/sdb &quot;mkpart primary 0% 100%&quot; # create other part parted -a optimal -s /dev/sdb &quot;mkpart logical 59G 459G&quot; parted -a optimal -s /dev/sdb &quot;mkpart logical 459G 859G&quot; # remove part parted -s /dev/sdb rm 2 parted -s /dev/sdb rm 3 分区对齐 $ cat /sys/block/sdb/queue/optimal_io_size 1048576 $ cat /sys/block/sdb/queue/minimum_io_size 262144 $ cat /sys/block/sdb/alignment_offset 0 $ cat /sys/block/sdb/queue/physical_block_size 512 $ mkpart primary 2048s 100% (parted) align-check optimal 1 1 aligned]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>parted</tag>
        <tag>kpartx</tag>
        <tag>losetup</tag>
        <tag>sfdisk</tag>
        <tag>e2fsck</tag>
        <tag>resize2fs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yum,wget,apt-get,npm,gem,yast,git,goAgent 代理 .Md]]></title>
    <url>%2Flinux%2FYum%E3%80%81wget%E3%80%81apt-get%E3%80%81npm%E3%80%81gem%E3%80%81yast%E3%80%81git%E3%80%81goAgent%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[yum 配置代理 $ vi /etc/yum.conf proxy=http://mycache.mydomain.com:808 用于 yum 连接的帐户细节 proxy_username=yum-user proxy_password=qwerty &gt; UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xd1 in position 72: ordinal not in range(128) $ rpm --import RPM-GPG-KEY-redhat-release wget 配置代理 # 配置 .wgetrc use_proxy=on http_proxy=http://proxy.yoyodyne.com:18023/ #ftp_proxy=http://proxy.yoyodyne.com:18023/ # 或者： $ wget -Y on &quot;http_proxy=http://192.168.88.57:808&quot; &quot;www.baidu.com&quot; # 进行断点下载示例 $ wget -c [-O master.zip] --no-check-certificate https://xxx.com/file.zip apt-get 配置代理 Acquire { Retries &quot;0 ″ ; HTTP { Proxy &quot;http://192.168.0.246:808&quot;; }; }; $ apt-get install postfix -c /etc/apt/apt.proxy.conf # 方法 2：将以下代码写入 /etc/apt/apt.conf( 永久使用 ) Acquire::http::proxy &quot;http:// 用户名 : 密码 @ 代理地址 : 端口 &quot;; Acquire::https::proxy &quot;https:// 用户名 : 密码 @ 代理地址 : 端口 &quot;; Acquire::ftp::proxy &quot;ftp:// 用户名 : 密码 @ 代理地址 : 端口 &quot;; curl 配置代理 $ curl -x 192.168.88.57:808 &quot;www.baidu.com&quot; $ vi /root/.bashrc export http_proxy = http://PROXYSERVER:18023 git 配置代理 $ export http_proxy=&quot;http://username:password@squid.vpsee.com:3128/&quot; $ export https_proxy=&quot;http://username:password@squid.vpsee.com:3128/&quot; - # 这样 git 就会自动使用环境变量里的代理服务器了。http 方式正常，但是 https 方式 git 就会提示 CA 证书不受信任了， # 可以通过以下方式把 goagent 的 CA 加到系统信任列表里： 1、$ sudo cp path/to/goagent/local/CA.crt /usr/share/ca-certificates/goagent.crt 2、$ sudo chmod a+r /usr/share/ca-certificates/goagent.crt 3、$ sudo dpkg-reconfigure ca-certificates - # 如果是 git clone git:// 的话麻烦一些（可能有的 git 源不提供 http/https 的方式 ) # 下载一个 connect.c $ gcc -o connect connect.c $ cp connect /bin/ $ echo &quot;connect -H http://192.168.88.57:808 $@&quot; &gt;/root/git_proxy $ chmod a+x /root/git_proxy $ git config --global core.gitproxy /root/git_proxy yast 配置代理 $ vi /etc/sysconfig/proxy PROXY_ENABLED=&quot;on&quot; HTTP_PROXY=&quot;http://192.168.11.35:808&quot; GoAgent 代理 $ modutil -changepw &quot;NSS Certificate DB&quot; -dbdir $HOME/.pki/nssdb # 查看证书 $ certutil -d sql:$HOME/.pki/nssdb -L # 导入证书 $ pk12util -d sql:$HOME/.pki/nssdb -i XXXX.pfx # GoAgent 证书导入 $ certutil -d sql:$HOME/.pki/nssdb -A -t TC -n &quot;GoAgent&quot; -i /tmp/CA.crt # 删除证书 $ certutil -d sql:$HOME/.pki/nssdb -D -t &quot;C,,&quot; -n GoAgent # 设置 : $ npm config set proxy=http://proxy.mysite.com:8080 或在 /root/.npmrc 中设置： $ proxy=http://192.168.109.1:808 # 取消 : $ npm config delete proxy # 设置 : $ https_proxy=http://192.168.109.1:1080 go get &lt;PACKAGE&gt; # 安装时加上 --http-proxy 参数 $ gem install --http-proxy http://proxy.mysite.com:8080 sass # 取消 : # 安装时不加上 --http-proxy 参数 $ gem install sass]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>yum</tag>
        <tag>wget</tag>
        <tag>apt-get</tag>
        <tag>npm</tag>
        <tag>gem</tag>
        <tag>yast</tag>
        <tag>goAgent</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装源_RedHat,CentOS 备用源]]></title>
    <url>%2Flinux%2FRedHat%E3%80%81CentOS%E5%9B%BD%E5%86%85%E5%A4%87%E7%94%A8%E5%AE%89%E8%A3%85%E6%BA%90%2F</url>
    <content type="text"><![CDATA[yum 更新 12345yum search fastestmirroryum install yum-fastestmirror* -yyum update yum*yum update kernel*yum update # ( 将链接中的 &quot;X&quot; 换为 7/6/5 即可下载不同版本的 repo) rpm -Uhv http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el&lt;X&gt;.rf.x86_64.rpm rpm -Uhv http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el&lt;X&gt;.rf.i686.rpm epel 源 (elrepo.org) yum install epel-release elrepo(update kernel) rpm -Uvh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm # ( 将链接中的 &quot;X&quot; 换为 7/6/5 即可下载不同版本的 repo) rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm # redhat/centos 6 rpm -Uvh http://download1.rpmfusion.org/free/el/updates/6/x86_64/rpmfusion-free-release-6-1.noarch.rpm rpm -Uvh http://download1.rpmfusion.org/free/el/updates/6/i386/rpmfusion-free-release-6-1.noarch.rpm rpm -Uvh http://download1.rpmfusion.org/nonfree/el/updates/6/i386/rpmfusion-nonfree-release-6-1.noarch.rpm # redhat/centos 7 only have x86_64 packages rpm -Uvh http://download1.rpmfusion.org/free/el/updates/7/x86_64/r/rpmfusion-free-release-7-1.noarch.rpm CentOS 中国科学技术大学 USTC mirror( 每小时更新一次 ) 地址：http://centos.ustc.edu.cn/ cd /etc/yum.repos.d mv CentOS-Base.repo CentOS-Base.repo.save-`date +%F` centos 7 1234567891011121314151617181920212223242526272829303132vi USTC.repo[base]name=CentOS-$releasever - Base#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#released updates[updates]name=CentOS-$releasever - Updates# mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extras# mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus# mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplusbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 centos 6 12345678910111213141516171819202122232425262728293031323334353637383940[base]name=CentOS-$releasever - Base - mirrors.ustc.edu.cnbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/os/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osgpgcheck=1gpgkey=https://mirrors.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6#released updates[updates]name=CentOS-$releasever - Updates - mirrors.ustc.edu.cnbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/updates/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesgpgcheck=1gpgkey=https://mirrors.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6#additional packages that may be useful[extras]name=CentOS-$releasever - Extras - mirrors.ustc.edu.cnbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/extras/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasgpgcheck=1gpgkey=https://mirrors.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.ustc.edu.cnbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/centosplus/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplusgpgcheck=1enabled=0gpgkey=https://mirrors.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6#contrib - packages by Centos Users[contrib]name=CentOS-$releasever - Contrib - mirrors.ustc.edu.cnbaseurl=https://mirrors.ustc.edu.cn/centos/$releasever/contrib/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=contribgpgcheck=1enabled=0gpgkey=https://mirrors.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6 网易开源镜像站 地址：http://mirrors.163.com/.help/centos.html 12345678910cd /etc/yum.repos.d# centos6wget http://mirrors.163.com/.help/CentOS6-Base-163.repo# centos7wget http://mirrors.163.com/.help/CentOS7-Base-163.repo# 生成缓存yum makecache # 删除 32 位组件： yum remove \*.i\?86 # 编辑 /etc/yum.conf 并加入以下一行： exclude = *.i?86]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>yum rpmforge</tag>
        <tag>国内源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装 Easy_install 及 Pip]]></title>
    <url>%2Flinux%2FLinux%E5%AE%89%E8%A3%85easy_install%E5%8F%8Apip%2F</url>
    <content type="text"><![CDATA[需要先将 python2.6 升级至 2.7，请参见： python2.6 升级至 python2.7 安装 easy_install # 获取软件包 $ wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-3.6.tar.gz # 解压 : $ tar -xvf setuptools-3.6.tar.gz &amp;&amp; cd setuptools-3.6 # 使用 Python 2.7.x 安装 setuptools /usr/local/bin/python2.7 setup.py install 更多 easy_install 用法见： easy_install 用法 安装 PIP # 下载方法 1 $ curl https://bootstrap.pypa.io/get-pip.py | python - # 下载方法 2 $ wget https://bootstrap.pypa.io/get-pip.pyy -O - | python # 安装方法 1 $ yum install python-pip # 安装方法 2 $ /usr/local/bin/easy_install pip ( 建议 , 如果升级使用此方法！ ) # 升级 pip $ /usr/local/bin/easy_install --upgrade pip # 升级 distribute(distribute 是 setuptools 的替代方案，pip 是 easy_install 的替代方案 ) $ pip install -U distribute # 升级 ez_setup $ curl https://bootstrap.pypa.io/ez_setup.py | python - $ pip install --no-cache-dir -r requirements.txt -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com &gt; 安装墙内 PIP http://realfavicongenerator.net/ easy_install 用法 # 1 直接安装： easy_install SQLObject # 2 使用下载页面地址安装 easy_install -f http://pythonpaste.org/package_index.html SQLObject # 3 直接给出下载 url 安装 easy_install http://example.com/path/to/MyPackage-1.2.3.tgz # 4 .egg 文件的安装 easy_install /my_downloads/OtherPackage-3.2.1-py2.3.egg # 5 跟新安装过的包 easy_install --upgrade PyProtocols # 6 安装已经下载和提取在当前目录下的包 easy_install . # 7 安装特定特定版本的库 easy_install &quot;SomePackage==2.0&quot; # 8 大于某个版本 easy_install &quot;SomePackage&gt;2.0 # 9 卸载库 easy_install -m PackageName]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>easy_install</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dnsmasq 使用本地 Hosts 配置提供 DNS 服务]]></title>
    <url>%2Flinux%2Fdns%2FDnsmasq%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0host%E4%B8%BADNS%2F</url>
    <content type="text"><![CDATA[使用 dnsmasq 提供外网 dns 服务 $ apt-get install dnsmasq # 将以下文本添加到 /etc/dnsmasq.conf 文件的最后： listen-address=127.0.0.1,OUTER_IP # 这里如果使用 0.0.0.0 会失败 addn-hosts=/etc/hosts # 直接解析本地的 hosts resolv-file=/etc/resolv.dnsmasq.conf # 可以增加本机的 dns 服务 (/etc/resolv.conf 里最多只生效三个 ) conf-dir=/etc/dnsmasq.d # 该目录下的所有文件都会解析 生成域名映射 # 在 /etc/dnsmasq.d/ 目录下新建一个文件，随意起个名字 vi /etc/dnsmasq.d/dns.conf # 指定你要映射的域名，例如 google.com，则将下面贴进 dns.conf 文件 address=&quot;/google.com/172.17.0.4&quot; 启动服务 /etc/init.d/dnsmasq start 测试 dig google.com @OUTER_IP --&gt; 172.17.0.4 本地 hosts 配合 NetworkManager 方式 $ cat /etc/NetworkManager/dnsmasq.d/hosts.conf addn-hosts=/etc/hosts $ sudo service networking restart $ sudo /etc/init.d/dns-clean restart $ host u1 $ nslookup u1 $ getent ahosts u1]]></content>
      <categories>
        <category>linux</category>
        <category>dns</category>
      </categories>
      <tags>
        <tag>dns dhcp</tag>
        <tag>dnsmasq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autossh]]></title>
    <url>%2Flinux%2FAutossh%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html 用 autossh 保证 ssh 隧道稳定性 : autossh -M 5122 -N -v -D localhost:8527 root@remote_ssh_server -p remote_ssh_port autossh 代理 export AUTOSSH_PIDFILE=/var/run/autossh.pid export AUTOSSH_POLL=60 export AUTOSSH_FIRST_POLL=30 export AUTOSSH_GATETIME=0 export AUTOSSH_DEBUG=1 autossh -M 0 -4 -fN -R 8080:127.0.0.1:80 -o &quot;ServerAliveInterval 60&quot; \ -o &quot;ServerAliveCountMax 3&quot; -o BatchMode=yes \ -o StrictHostKeyChecking=no USER@HOSTNAME]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Screen、nohup、setsid、disown 后台运行]]></title>
    <url>%2Flinux%2FScreen%E3%80%81nohup%E3%80%81setsid%E3%80%81disown%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[screen 后台 screen -ls -&gt; 列出当前所有的 session screen -r yourname -&gt; 回到 yourname 这个 session screen -d yourname -&gt; 远程 detach 某个 session screen -d -r yourname -&gt; 结束当前 session 并回到 yourname 这个 session # 有用的命令，可以做为同步演示用 , 比 script 强大 screen -x &lt;SESSION_NAME&gt; screen -X -S [session_you_want_to_kill] quit screen -Sdm &lt;SCREEN_NAME&gt; &lt;DO_SOME_COMMAND&gt; nohup 后台 nohup ping www.ibm.com &amp; setsid 后台 setsid ping www.ibm.com (ctrl+c 后就跑后台去了 ) subshell 后台 (ping www.ibm.com &amp;) disown 后台 disown -h JOBID]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>screen</tag>
        <tag>nohup</tag>
        <tag>setsid</tag>
        <tag>disown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bind 安装配置]]></title>
    <url>%2Flinux%2FBind%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[参考： http://linux.vbird.org/linux_server/0350dns.php#server_settings DDNS 的安装见：http://wenku.baidu.com/view/31f263d233d4b14e8524687e.html 安装 $ rpm -ivh bind bind-chroot 配置 1. 生成 rndc key $ rndc-confgen -r /dev/random &gt;/etc/rndc.conf $ chown root:named /etc/rndc.conf 2. 配置 named.conf $ vi /etc/named.conf options { // Put files that named is allowed to write in the data/ directory: directory &quot;/var/named&quot;; // &quot;Working&quot; directory dump-file &quot;data/cache_dump.db&quot;; statistics-file &quot;data/named_stats.txt&quot;; memstatistics-file &quot;data/named_mem_stats.txt&quot;; allow-query { any; }; recursion yes; listen-on port 53 { any; }; allow-transfer { none; }; // 不允许别人进行 zone 转移 , 如果有 slave DNS，则可以开启 }; acl intranet { 192.168.1.0/24; }; // 本地来源 IP acl internet { ! 192.168.1.0/24; any; }; // 外部来源 IP. 惊叹号表示反向选择 match-clients { &quot;intranet&quot;; }; // 吻合的才使用底下的 zone zone &quot;.&quot; IN { type hint; file &quot;named.ca&quot;; }; zone &quot;xdol.vicp.net&quot; IN { type master; file &quot;named.xdol.vicp.net&quot;; }; zone &quot;1.168.192.in-addr.arpa&quot; IN { type master; file &quot;named.192.168.1&quot;; }; }; view &quot;wan&quot; { match-clients { &quot;internet&quot;; }; // 吻合的才使用底下的 zone zone &quot;.&quot; IN { type hint; file &quot;named.ca&quot;; }; zone &quot;xdol.vicp.net&quot; IN { type master; file &quot;named.xdol.vicp.net.inter&quot;; }; }; key &quot;rndc-key&quot; { // 这里是 rndc 的密钥，需要修改为 /etc/rndc.conf 中一样的 secret algorithm hmac-md5; secret &quot;wFLLOzcaq3T2CFNvbT3d7g==&quot;; }; controls { inet 127.0.0.1 port 953 allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; }; }; logging { // 防止外部服务器错误导致 log 记录 category lame-servers { null; }; }; zone 配置 1. 正向 zone 内网配置 $ vi /var/named/named.xdol.vicp.net $TTL 600 @ IN SOA master.xdol.vicp.net. dongchaojun.gmail.com. ( 2012040702 3H 15M 1W 1D ); @ IN NS master.xdol.vicp.net. ;DNS 服务器名称 master.xdol.vicp.net. IN A 192.168.1.109 ;DNS 服务器 IP @ IN MX 10 www.xdol.vicp.net. ; 邮件服务器 www.xdol.vicp.net. IN A 192.168.1.109 ; 内部网卡的 IP ftp.xdol.vicp.net. IN CNAME www.xdol.vicp.net. ssh.xdol.vicp.net. IN CNAME www.xdol.vicp.net. client.xdol.vicp.net. IN A 192.168.1.246 2. 正向 zone 外网配置 $ vi /var/named/named.xdol.vicp.net.inter $TTL 600 @ IN SOA master.xdol.vicp.net. dongchaojun.gmail.com. ( 2012040702 3H 15M 1W 1D ); @ IN NS master.xdol.vicp.net. ;DNS 服务器名称 master.xdol.vicp.net. IN A 11.11.11.11 ;DNS 服务器 IP @ IN MX 10 www.xdol.vicp.net. ; 邮件服务器 www.xdol.vicp.net. IN A 11.11.11.11 ; 外部网卡的 IP ftp.xdol.vicp.net. IN CNAME www.xdol.vicp.net. ssh.xdol.vicp.net IN CNAME www.xdol.vicp.net. client.xdol.vicp.net. IN A 192.168.1.246 3. 反向 zone 内、外网设置 ( 外网不需要反向 zone) $ vi /var/named/named.192.168.1 $TTL 600 @ IN SOA master.xdol.vicp.net. dongchaojun.gmail.com. ( 2012040702 3H 15M 1W 1D ) @ IN NS master.xdol.vicp.net. 109 IN PTR master.xdol.vicp.net. ; 将原来的 A 改为 PTR 标志而已 109 IN PTR www.xdol.vicp.net. 246 IN PTR client.xdol.vicp.net. 启动服务 service named start chkconfig named on 配置 DDNS( 可选 ) 1. DNS 服务端生成主机端的 key( 在当前目录下会生成一个公钥及一个私钥 ) dnssec-keygen -r /dev/urandom -a HMAC-MD5 -b 512 -n HOST greatwall $ vi /etc/named.conf // 先在任意地方加入這個 Key 的相關密碼資訊！ ( 加而不是更新其它的 ) key &quot;greatwall&quot; { algorithm hmac-md5; secret &quot;xZmUo8ozG8f2OSg/cqH8Bqxk59Ho8....3s9IjUxpFB4Q==&quot;; // 这里换成算出的公钥 cat 出来的内容 }; zone &quot;centos.vbird&quot; IN { type master; file &quot;named.centos.vbird&quot;; update-policy { // 这个 update-policy 及后面就是添加的 grant greatwall name greatwall.xdol.vicp.net. A; }; }; $ chmod g+w /var/named $ chown named /var/named/named.centos.vbird $ /etc/init.d/named restart $ setsebool -P named_write_master_zones=1 // selinux 的 将 ddns 的 key 传给客户端，并在客户端 crontab 中添加以下自动运行的脚本 #!/bin/bash # # Update your Dynamic IP by using BIND 9 &#39;s tools # ############################################### # History # 2004/10/27 VBird First time release # ############################################## PATH=/sbin:/bin:/usr/sbin:/usr/bin export PATH # 0. keyin your parameters basedir=&quot;/usr/local/ddns&quot; # working directory keyfile=&quot;$basedir&quot;/&quot;Kgreatwall.+157+60932.key&quot; # your ddns&#39; key (filename) ttl=600 # the ttl time ( 10 min. ) outif=&quot;eth0&quot; # Your interface (connect to internet) hostname=&quot;greatwall.xdol.vicp.net&quot; # Your hostname servername=&quot;192.168.1.109&quot; # The update primary DNS server name (or IP) showmesg=no # if yes then show messages # Get your new IP newip=`ifconfig &quot;$outif&quot; | grep &#39;inet addr&#39; | \ awk &#39;{print $2}&#39; | sed -e &quot;s/addr\://&quot;` checkip=`echo $newip | grep &quot;^[0-9]&quot;` if [ &quot;$checkip&quot; == &quot;&quot; ]; then echo &quot;$0: The interface can&#39;t connect internet....&quot; exit 1 fi # check if the DNS is the same with your IP dnsip=`host $hostname | head -n 1 | awk &#39;{print $4}&#39;` if [ &quot;$newip&quot; == &quot;$dnsip&quot; ]; then if [ &quot;$showmesg&quot; == &quot;yes&quot; ]; then echo &quot;$0: The IP is the same with DNS, Don&#39;t change it.&quot; fi exit 0 fi # create the temporal file tmpfile=$basedir/ns_auto_update.txt cd $basedir echo &quot;server $servername&quot; &gt; $tmpfile echo &quot;update delete $hostname A &quot; &gt;&gt; $tmpfile echo &quot;update add $hostname $ttl A $newip&quot; &gt;&gt; $tmpfile echo &quot;send&quot; &gt;&gt; $tmpfile # send yo # 附录： 名词解释 TLD: Top Level Domain ccTLD: Country code TLD TTL: Time to live 申請 DNS 領域查詢授權 NS 记录： NameServer A 记录： Address MX 记录： Mail CNAME 實際代表這個主機別名的主機名字 PTR：就是指向 (PoinTeR) 的縮寫，後面記錄的資料就是反解到主機名稱囉！ 記錄 . 的 zone 的類型，就被我們稱為 hint 類型 在 domain 的部分，若可能的話，請盡量使用 FQDN，亦即是主機名稱結尾加上一個小數點 SOA 主要是與領域有關，所以前面當然要寫 ksu.edu.tw 這個領域名。而 SOA 後面共會接七個參數，這七個參數的意義依序是： 1.Master DNS 伺服器主機名稱：這個領域主要是哪部 DNS 作為 master 的意思。在本例中， dns1.ksu.edu.tw 為 ksu.edu.tw 這個領域的主要 DNS 伺服器囉； 管理員的 email：那麼管理員的 email 為何？發生問題可以聯絡這個管理員。要注意的是， 由於 @ 在資料庫檔案中是有特別意義的，因此這裡就將 abuse@mail.ksu.edu.tw 改寫成 abuse.mail.ksu.edu.tw ，這樣看的懂了嗎？ Refresh &gt;= Retry 2 Refresh + Retry &lt; Expire Expire &gt;= Rrtry 10 Expire &gt;= 7Days]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[儿子的生日]]></title>
    <url>%2Fm%2F%E5%84%BF%E5%AD%90%E7%9A%84%E7%94%9F%E6%97%A5%2F</url>
    <content type="text"><![CDATA[生日照片]]></content>
  </entry>
  <entry>
    <title><![CDATA[Postgresql 安装]]></title>
    <url>%2Fdatabase%2FPostgresql%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[$ yum -y install readline-devel zlib-devel make gcc gcc-c++ openldap openldap-devel \ openssl openssl-devel perl perl-devel perl-ExtUtils* python-devel tcl-devel pam-devel libxslt-devel $ yum -y install wget gcc systemtap systemtap-sdt-devel \ sgml-common docbook stylesheets openjade sgml-tools xsltproc \ libxml2 libxml2-devel bison flex libreadline6-devel 安装 12345678910111213141516# 配置用户、环境变量$ useradd postgres$ vim /etc/profile export PATH=$PATH:$HOME/bin:/usr/local/pgsql/bin$ source /etc/profile$ wget https://ftp.postgresql.org/pub/source/v9.5.1/postgresql-9.5.1.tar.bz2$ bzcat postgresql-9.5.1.tar.bz2 | tar xBpf -$ cd postgresql-9.5.1$ ./configure --with-perl --with-python --with-tcl --with-openssl --without-ldap \ --with-libxml --with-libxslt --enable-thread-safety --with-wal-blocksize=64 \ --with-blocksize=32 --with-wal-segsize=64 -enable-dtrace --with-pam$ make &amp;&amp; make install 初始化数据库 1234567891011mkdir -p /pgdatachown postgres /pgdatasu - postgres/usr/local/pgsql/bin/initdb -D /pgdata/ $ vim /pgdata/pg_hba.conf host all all 0.0.0.0/0 trust $ vim /pgdata/postgresql.conf listen_addresses = '*' max_connections = 1500 启动数据库 [快速] $ /usr/local/pgsql/bin/pg_ctl [-m fast] -D /pgdata/ -l ~/pg_logfile start 创建并导入库 12345su postgrespsqlpostgres=# create database &lt;DB_NAME&gt;;postgres=# \c &lt;DB_NAME&gt;;\i &lt;DB_FILE&gt;.sql]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Systemd,systemctl 命令]]></title>
    <url>%2Flinux%2FSystemd%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Systemd 和 Systemctl 基础命令 查看目前状态： systemctl status &lt;SERVICE_NAME&gt; [ 启动 | 停止 ]: systemctl [ start | stop ] &lt;SERVICE_NAME&gt; 类似查 chkconfig: systemctl list-unit-files | grep &lt;SERVICE_NAME&gt; systemctl is-enabled &lt;SERVICE_NAME&gt; [不]自动启动： systemctl [ disable | enable ] &lt;SERVICE_NAME&gt; # 系统级的 systemd 在 /etc/systemd/system # 用户级的 systemd 在 /usr/lib/systemd/system/ （main） # 运行级的 systemd 在 /run/systemd/system # 如删除服务，需要： systemctl stop &lt;SERVICE_NAME&gt; systemctl disable &lt;SERVICE_NAME&gt; rm -rf /[etc|run]/systemd/system/&lt;SERVICE_NAME&gt; systemctl daemon-reload `systemctl reset-failed` # 只有运行这样才可以看到服务消失 1. 首先检查你的系统中是否安装有 systemd 并确定当前安装的版本 [root@manage ~]# systemctl --version systemd 215 +PAM +AUDIT +SELINUX +IMA +SYSVINIT +LIBCRYPTSETUP +GCRYPT +ACL +XZ -SECCOMP -APPARMOR 上例中很清楚地表明，我们安装了 215 版本的 systemd。 [root@manage ~]# whereis systemd systemd: /usr/lib/systemd /etc/systemd /usr/share/systemd /usr/share/man/man1/systemd.1.gz [root@manage ~]# whereis systemctl systemctl: /usr/bin/systemctl /usr/share/man/man1/systemctl.1.gz 3. 检查 systemd 是否运行 [root@manage ~]# ps -eaf | grep [s]ystemd root 1 0 0 16:27 ? 00:00:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 23 root 444 1 0 16:27 ? 00:00:00 /usr/lib/systemd/systemd-journald root 469 1 0 16:27 ? 00:00:00 /usr/lib/systemd/systemd-udevd root 555 1 0 16:27 ? 00:00:00 /usr/lib/systemd/systemd-logind dbus 556 1 0 16:27 ? 00:00:00 /bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation 注意：systemd 是作为父进程（PID=1）运行的。在上面带（-e）参数的 ps 命令输出中，选择所有进程，（-a）选择除会话前导外的所有进程，并使用（-f）参数输出完整格式列表（即 -eaf）。 4. 分析 systemd 启动进程 [root@manage ~]# systemd-analyze Startup finished in 487ms (kernel) + 2.776s (initrd) + 20.229s (userspace) = 23.493s 5. 分析启动时各个进程花费的时间 [root@manage ~]# systemd-analyze blame 8.565s mariadb.service 7.991s webmin.service 6.095s postfix.service 4.311s httpd.service 3.926s firewalld.service 3.780s kdump.service 3.238s tuned.service 1.712s network.service 1.394s lvm2-monitor.service 1.126s systemd-logind.service .... 6. 分析启动时的关键链 [root@manage ~]# systemd-analyze critical-chain The time after the unit is active or started is printed after the &quot;@&quot; character. The time the unit takes to start is printed after the &quot;+&quot; character. multi-user.target @20.222s └─ mariadb.service @11.657s +8.565s └─ network.target @11.168s └─ network.service @9.456s +1.712s └─ NetworkManager.service @8.858s +596ms └─ firewalld.service @4.931s +3.926s └─ basic.target @4.916s └─ sockets.target @4.916s └─ dbus.socket @4.916s └─ sysinit.target @4.905s └─ systemd-update-utmp.service @4.864s +39ms └─ auditd.service @4.563s +301ms └─ systemd-tmpfiles-setup.service @4.485s +69ms └─ rhel-import-state.service @4.342s +142ms └─ local-fs.target @4.324s └─ boot.mount @4.286s +31ms └─ systemd-fsck@dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d19608096 └─ dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.device @4 重要：Systemctl 接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。 7. 列出所有可用单元 state =[ static | enabled | disabled | invalid ] type =[ service | target | mount | socket | slice | scope | timer | path ] [root@manage ~]# systemctl list-unit-files [ --type=TYPE ] [ --state=STATE ] 这个作用类似于 chkconfig UNIT FILE STATE proc-sys-fs-binfmt_misc.automount static dev-hugepages.mount static dev-mqueue.mount static proc-sys-fs-binfmt_misc.mount static sys-fs-fuse-connections.mount static sys-kernel-config.mount static sys-kernel-debug.mount static tmp.mount disabled brandbot.path disabled ..... 8. 列出所有运行中单元 [root@manage ~]# systemctl list-units UNIT LOAD ACTIVE SUB DESCRIPTION proc-sys-fs-binfmt_misc.automount loaded active waiting Arbitrary Executable File Formats File Syste sys-devices-pc...0-1:0:0:0-block-sr0.device loaded active plugged VBOX_CD-ROM sys-devices-pc...:00:03.0-net-enp0s3.device loaded active plugged PRO/1000 MT Desktop Adapter sys-devices-pc...00:05.0-sound-card0.device loaded active plugged 82801AA AC&#39;97 Audio Controller sys-devices-pc...:0:0-block-sda-sda1.device loaded active plugged VBOX_HARDDISK sys-devices-pc...:0:0-block-sda-sda2.device loaded active plugged LVM PV Qzyo3l-qYaL-uRUa-Cjuk-pljo-qKtX-VgBQ8 [root@manage ~]# systemctl --failed UNIT LOAD ACTIVE SUB DESCRIPTION kdump.service loaded failed failed Crash recovery kernel arming LOAD = Reflects whether the unit definition was properly loaded. ACTIVE = The high-level unit activation state, i.e. generalization of SUB. SUB = The low-level unit activation state, values depend on unit type. 1 loaded units listed. Pass --all to see loaded but inactive units, too. To show all installed unit files use &#39;systemctl list-unit-files&#39;. [root@manage ~]# systemctl is-enabled crond.service enabled [root@manage ~]# systemctl is-active httpd.service [root@manage ~]# systemctl enable httpd.service [root@manage ~]# systemctl disable httpd.service 12. 检查某个单元或服务是否运行 [root@manage ~]# systemctl status firewalld.service firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled) Active: active (running) since Tue 2015-04-28 16:27:55 IST; 34min ago Main PID: 549 (firewalld) CGroup: /system.slice/firewalld.service └─ 549 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid Apr 28 16:27:51 tecmint systemd[1]: Starting firewalld - dynamic firewall daemon... Apr 28 16:27:55 tecmint systemd[1]: Started firewalld - dynamic firewall daemon. 使用 Systemctl 控制并管理服务 [root@manage ~]# systemctl start httpd.service [root@manage ~]# systemctl restart httpd.service [root@manage ~]# systemctl stop httpd.service [root@manage ~]# systemctl reload httpd.service [root@manage ~]# systemctl status httpd.service [root@manage ~]# systemctl show -p LoadState vdsm.service httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled) Active: active (running) since Tue 2015-04-28 17:21:30 IST; 6s ago Process: 2876 ExecStop=/bin/kill -WINCH ${MAINPID} (code=exited, status=0/SUCCESS) Main PID: 2881 (httpd) Status: &quot;Processing requests...&quot; CGroup: /system.slice/httpd.service ├─ 2881 /usr/sbin/httpd -DFOREGROUND ├─ 2884 /usr/sbin/httpd -DFOREGROUND ├─ 2885 /usr/sbin/httpd -DFOREGROUND ├─ 2886 /usr/sbin/httpd -DFOREGROUND ├─ 2887 /usr/sbin/httpd -DFOREGROUND └─ 2888 /usr/sbin/httpd -DFOREGROUND Apr 28 17:21:30 tecmint systemd[1]: Starting The Apache HTTP Server... Apr 28 17:21:30 tecmint httpd[2881]: AH00558: httpd: Could not reliably determine the server&#39;s fully q...ssage Apr 28 17:21:30 tecmint systemd[1]: Started The Apache HTTP Server. Hint: Some lines were ellipsized, use -l to show in full. 注意：当我们使用 systemctl 的 start，restart，stop 和 reload 命令时，我们不会从终端获取到任何输出内容，只有 status 命令可以打印输出。 [root@manage ~]# systemctl mask httpd.service ln -s &#39;/dev/null&#39; &#39;/etc/systemd/system/httpd.service&#39; # 删除服务 [root@manage ~]# systemctl unmask httpd.service rm &#39;/etc/systemd/system/httpd.service&#39; [root@manage ~]# systemctl kill httpd [root@manage ~]# systemctl status httpd httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled) Active: failed (Result: exit-code) since Tue 2015-04-28 18:01:42 IST; 28min ago Main PID: 2881 (code=exited, status=0/SUCCESS) Status: &quot;Total requests: 0; Current requests/sec: 0; Current traffic: 0 B/sec&quot; Apr 28 17:37:29 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:29 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:39 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:39 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:49 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:49 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:59 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:59 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 18:01:42 tecmint systemd[1]: httpd.service: control process exited, code=exited status=226 Apr 28 18:01:42 tecmint systemd[1]: Unit httpd.service entered failed state. Hint: Some lines were ellipsized, use -l to show in full. 使用 Systemctl 控制并管理挂载点 17. 列出所有系统挂载点 [root@manage ~]# systemctl list-unit-files --type=mount UNIT FILE STATE dev-hugepages.mount static dev-mqueue.mount static proc-sys-fs-binfmt_misc.mount static sys-fs-fuse-connections.mount static sys-kernel-config.mount static sys-kernel-debug.mount static tmp.mount disabled [root@manage ~]# systemctl start tmp.mount [root@manage ~]# systemctl stop tmp.mount [root@manage ~]# systemctl restart tmp.mount [root@manage ~]# systemctl reload tmp.mount [root@manage ~]# systemctl status tmp.mount tmp.mount - Temporary Directory Loaded: loaded (/usr/lib/systemd/system/tmp.mount; disabled) Active: active (mounted) since Tue 2015-04-28 17:46:06 IST; 2min 48s ago Where: /tmp What: tmpfs Docs: man:hier(7) http://www.freedesktop.org/wiki/Software/systemd/APIFileSystems Process: 3908 ExecMount=/bin/mount tmpfs /tmp -t tmpfs -o mode=1777,strictatime (code=exited, status=0/SUCCESS) Apr 28 17:46:06 tecmint systemd[1]: Mounting Temporary Directory... Apr 28 17:46:06 tecmint systemd[1]: tmp.mount: Directory /tmp to mount over is not empty, mounting anyway. Apr 28 17:46:06 tecmint systemd[1]: Mounted Temporary Directory. 19. 在启动时激活、启用或禁用挂载点（系统启动时自动挂载） [root@manage ~]# systemctl is-active tmp.mount [root@manage ~]# systemctl enable tmp.mount [root@manage ~]# systemctl disable tmp.mount [root@manage ~]# systemctl mask tmp.mount ln -s &#39;/dev/null&#39; &#39;/etc/systemd/system/tmp.mount&#39; [root@manage ~]# systemctl unmask tmp.mount rm &#39;/etc/systemd/system/tmp.mount&#39; 使用 Systemctl 控制并管理套接口 21. 列出所有可用系统套接口 [root@manage ~]# systemctl list-unit-files --type=socket UNIT FILE STATE dbus.socket static dm-event.socket enabled lvm2-lvmetad.socket enabled rsyncd.socket disabled sshd.socket disabled syslog.socket static systemd-initctl.socket static systemd-journald.socket static systemd-shutdownd.socket static systemd-udevd-control.socket static systemd-udevd-kernel.socket static 11 unit files listed. [root@manage ~]# systemctl start cups.socket [root@manage ~]# systemctl restart cups.socket [root@manage ~]# systemctl stop cups.socket [root@manage ~]# systemctl reload cups.socket [root@manage ~]# systemctl status cups.socket cups.socket - CUPS Printing Service Sockets Loaded: loaded (/usr/lib/systemd/system/cups.socket; enabled) Active: active (listening) since Tue 2015-04-28 18:10:59 IST; 8s ago Listen: /var/run/cups/cups.sock (Stream) Apr 28 18:10:59 tecmint systemd[1]: Starting CUPS Printing Service Sockets. Apr 28 18:10:59 tecmint systemd[1]: Listening on CUPS Printing Service Sockets. 23. 在启动时激活套接口，并启用或禁用它（系统启动时自启动） [root@manage ~]# systemctl is-active cups.socket [root@manage ~]# systemctl enable cups.socket [root@manage ~]# systemctl disable cups.socket 服务的 CPU 利用率（分配额） [root@manage ~]# systemctl show -p CPUShares httpd.service CPUShares=1024 [root@manage ~]# 注意：各个服务的默认 CPU 分配份额 =1024，你可以增加 / 减少某个进程的 CPU 分配份额。 26. 将某个服务（httpd.service）的 CPU 分配份额限制为 2000 CPUShares/ [root@manage ~]# systemctl set-property httpd.service CPUShares=2000 [root@manage ~]# systemctl show -p CPUShares httpd.service CPUShares=2000 [root@manage ~]# 注意：当你为某个服务设置 CPUShares，会自动创建一个以服务名命名的目录（如 httpd.service），里面包含了一个名为 90-CPUShares.conf 的文件，该文件含有 CPUShare 限制信息，你可以通过以下方式查看该文件： [root@manage ~]# vi /etc/systemd/system/httpd.service.d/90-CPUShares.conf [Service] CPUShares=2000 [root@manage ~]# systemctl show httpd Id=httpd.service Names=httpd.service Requires=basic.target Wants=system.slice WantedBy=multi-user.target Conflicts=shutdown.target Before=shutdown.target multi-user.target After=network.target remote-fs.target nss-lookup.target systemd-journald.socket basic.target system.slice Description=The Apache HTTP Server LoadState=loaded ActiveState=active SubState=running FragmentPath=/usr/lib/systemd/system/httpd.service .... [root@manage ~]# systemd-analyze critical-chain httpd.service The time after the unit is active or started is printed after the &quot;@&quot; character. The time the unit takes to start is printed after the &quot;+&quot; character. httpd.service +142ms └─ network.target @11.168s └─ network.service @9.456s +1.712s └─ NetworkManager.service @8.858s +596ms └─ firewalld.service @4.931s +3.926s └─ basic.target @4.916s └─ sockets.target @4.916s └─ dbus.socket @4.916s └─ sysinit.target @4.905s └─ systemd-update-utmp.service @4.864s +39ms └─ auditd.service @4.563s +301ms └─ systemd-tmpfiles-setup.service @4.485s +69ms └─ rhel-import-state.service @4.342s +142ms └─ local-fs.target @4.324s └─ boot.mount @4.286s +31ms └─ systemd-fsck@dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.service @4.092s +149ms └─ dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.device @4.092s [root@manage ~]# systemctl list-dependencies httpd.service httpd.service ├─ system.slice └─ basic.target ├─ firewalld.service ├─ microcode.service ├─ rhel-autorelabel-mark.service ├─ rhel-autorelabel.service ├─ rhel-configure.service ├─ rhel-dmesg.service ├─ rhel-loadmodules.service ├─ paths.target ├─ slices.target │ ├─ -.slice │ └─ system.slice ├─ sockets.target │ ├─ dbus.socket .... 30. 按等级列出控制组 [root@manage ~]# systemd-cgls ├─ 1 /usr/lib/systemd/systemd --switched-root --system --deserialize 23 ├─ user.slice │ └─ user-0.slice │ └─ session-1.scope │ ├─ 2498 sshd: root@pts/0 │ ├─ 2500 -bash │ ├─ 4521 systemd-cgls │ └─ 4522 systemd-cgls └─ system.slice ├─ httpd.service │ ├─ 4440 /usr/sbin/httpd -DFOREGROUND │ ├─ 4442 /usr/sbin/httpd -DFOREGROUND │ ├─ 4443 /usr/sbin/httpd -DFOREGROUND │ ├─ 4444 /usr/sbin/httpd -DFOREGROUND │ ├─ 4445 /usr/sbin/httpd -DFOREGROUND │ └─ 4446 /usr/sbin/httpd -DFOREGROUND ├─ polkit.service │ └─ 721 /usr/lib/polkit-1/polkitd --no-debug .... [root@manage ~]# systemd-cgtop Path Tasks %CPU Memory Input/s Output/s / 83 1.0 437.8M - - /system.slice - 0.1 - - - /system.slice/mariadb.service 2 0.1 - - - /system.slice/tuned.service 1 0.0 - - - /system.slice/httpd.service 6 0.0 - - - /system.slice/NetworkManager.service 1 - - - - /system.slice/atop.service 1 - - - - /system.slice/atopacct.service 1 - - - - /system.slice/auditd.service 1 - - - - /system.slice/crond.service 1 - - - - /system.slice/dbus.service 1 - - - - /system.slice/firewalld.service 1 - - - - /system.slice/lvm2-lvmetad.service 1 - - - - /system.slice/polkit.service 1 - - - - /system.slice/postfix.service 3 - - - - /system.slice/rsyslog.service 1 - - - - /system.slice/system-getty.slice/getty@tty1.service 1 - - - - /system.slice/systemd-journald.service 1 - - - - /system.slice/systemd-logind.service 1 - - - - /system.slice/systemd-udevd.service 1 - - - - /system.slice/webmin.service 1 - - - - /user.slice/user-0.slice/session-1.scope 3 - - - - 控制系统运行等级 32. 启动系统救援模式 [root@manage ~]# systemctl rescue Broadcast message from root@tecmint on pts/0 (Wed 2015-04-29 11:31:18 IST): The system is going down to rescue mode NOW! [root@manage ~]# systemctl emergency Welcome to emergency mode! After logging in, type &quot;journalctl -xb&quot; to view system logs, &quot;systemctl reboot&quot; to reboot, &quot;systemctl default&quot; to try again to boot into default mode. [root@manage ~]# systemctl get-default multi-user.target 35. 启动运行等级 5，即图形模式 [root@manage ~]# systemctl isolate runlevel5.target 或 [root@manage ~]# systemctl isolate graphical.target 36. 启动运行等级 3，即多用户模式（命令行） [root@manage ~]# systemctl isolate runlevel3.target 或 [root@manage ~]# systemctl isolate multiuser.target [root@manage ~]# systemctl set-default runlevel3.target [root@manage ~]# systemctl set-default runlevel5.target [root@manage ~]# systemctl reboot [root@manage ~]# systemctl halt [root@manage ~]# systemctl suspend [root@manage ~]# systemctl hibernate [root@manage ~]# systemctl hybrid-sleep]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>systemd</tag>
        <tag>systemctl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Supervisor 安装与配置]]></title>
    <url>%2Flinux%2FSupervisor%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装 12345678# 建议使用 yum 安装yum install supervisor# 也可以使用 pip 安装pip install supervisor# 生成配置文件echo_supervisord_conf &gt;/etc/supervisord.conf 配置 生成的配置文件不用修改，直接在最后加下自己的配置，以下是样例 123456789101112131415[program:mysql]environment=API_UMBRELLA_CONFIG="/opt/api-umbrella/var/run/runtime_config.yml" # 可选directory=/opt/api-umbrella/embedded/apps/web/current # 可选command=service mysqld start # 必选，启动命令autorestart=true # 必选，自动启动redirect_stderr=true # 可选stdout_syslog=true # 可选[program:opsview]command=service opsview startautorestart=true[program:opsview-web]command=service opsview-web startautorestart=true 启动 $ service supervisord start &gt; 如果使用 pip 安装，需要自已写启动脚本 supervisorctl status remote-launcher `RUNNING` pid 11087, uptime 9 days, 2:49:14]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文文案排版指北]]></title>
    <url>%2Fmarkdown%2F%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[Other languages: English Chinese Traditional Chinese Simplified 目录 空格 中英文之间需要增加空格 中文与数字之间需要增加空格 数字与单位之间需要增加空格 全角标点与其他字符之间不加空格 -ms-text-autospace to the rescue? 标点符号 不重复使用标点符号 全角和半角 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 专有名词使用正确的大小写 不要使用不地道的缩写 争议 链接之间增加空格 简体中文使用直角引号 工具 谁在这样做？ 参考文献 空格 与大家共勉之。」——vinta/paranoid-auto-spacing 完整的正确用法： 例外：度／百分比与数字之间不需要增加空格： 刚刚买了一部 iPhone，好开心！ 刚刚买了一部 iPhone ，好开心！ -ms-text-autospace to the rescue? 标点符号 德国队竟然战胜了巴西队！ 使用全角中文标点 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 嗨 ! 你知道嘛 ? 今天前台的小妹跟我说 &quot; 喵 &quot; 了哎 ! 嗨 ! 你知道嘛 ? 今天前台的小妹跟我说 &quot; 喵 &quot; 了哎 ! 核磁共振成像 (NMRI) 是什么原理都不知道 ? JFGI! 核磁共振成像 (NMRI) 是什么原理都不知道 ?JFGI! 数字使用半角字符 名词 专有名词使用正确的大小写 使用 GitHub 登录 使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 g ｲんĤЦ 8 登录 不要使用不地道的缩写 争议 链接之间增加空格 工具 仓库 语言 vinta/paranoid-auto-spacing JavaScript huei90/pangu.node Node.js huacnlee/auto-correct Ruby sparanoid/space-lover PHP (WordPress) nauxliu/auto-correct PHP ricoa/copywriting-correct PHP hotoo/pangu.vim Vim sparanoid/grunt-auto-spacing Node.js (Grunt) hjiang/scripts/add-space-between-latin-and-cjk Python 谁在这样做？ 网站 文案 UGC Apple 中国 Yes N/A Apple 香港 Yes N/A Apple 台湾 Yes N/A Microsoft 中国 Yes N/A Microsoft 香港 Yes N/A Microsoft 台湾 Yes N/A LeanCloud Yes N/A 知乎 Yes 部分用户达成 V2EX Yes Yes SegmentFault Yes 部分用户达成 Apple4us Yes N/A 豌豆荚 Yes N/A Ruby China Yes 标题达成 PHPHub Yes 标题达成 少数派 Yes N/A Guidelines for Using Capital Letters Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Corrently - wikiHow 格式 - openSUSE 全角和半角 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>排版</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用监控工具]]></title>
    <url>%2Fmonitor%2F%E5%B8%B8%E7%94%A8%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Sysdig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 网络sysdig -c topprocs_net # 查看网络带宽占用最多的进程sysdig -c fdcount_by fd.sport "evt.type=accept" # 查看连接最多的服务端口sysdig -c fdcount_by fd.cip "evt.type=accept" # 查看客户端连接最多的 IP_ADDR_OF_SERVERsysdig -p "%proc.name %fd.name" "evt.type=accept and proc.name != httpd" # 列出不是访问 apache 服务的访问连接# IOsysdig -c topprocs_file # 查看使用硬盘带宽最多的进程sysdig -c fdcount_by proc.name "fd.type=file" # 列出使用大量文件描述符的进程sysdig -c fdbytes_by fd.directory "fd.type=file" # 读写磁盘最多的目录sysdig -c fdbytes_by fd.filename "fd.directory=/tmp/" # /tmp 中读写最多的文件sysdig -c fdbytes_by fd.type # 动态根据 FD 的类型显示 I/Osysdig -A -c echo_fds "fd.filename=passwd" # 动态跟踪所有名为 passwd 的文件的 I/Osysdig -c topfiles_bytes # 读写字节最多的文件sysdig -c topfiles_bytes proc.name=httpd # 读写字节最多的 APACHE 文件sysdig -p "%12user.name %6proc.pid %12proc.name %3fd.num %fd.typechar %fd.name" evt.type=open # 侦测文件被打开sysdig -c topprocs_cpu # 观察 CPU 占用最高的进程sysdig -c topprocs_cpu evt.cpu=0 # 观察 CPU0 的最高占用sysdig -s4096 -A -c stdout proc.name=nginx # 观察 cat 进程的输出sysdig -c topfiles_timesysdig -c topfiles_time proc.name=httpdsysdig -c topprocs_errorssysdig -c topfiles_errorssysdig fd.type=file and evt.failed=truesysdig "proc.name=httpd and evt.type=open and evt.failed=true"sysdig -c topscalls_timesysdig -c topscalls "evt.failed=true"sysdig -p "%12user.name %6proc.pid %12proc.name %3fd.num %fd.typechar %fd.name" evt.type=open and evt.failed=truesysdig -c fileslower 1# 安全sysdig -p"%evt.arg.path" "evt.type=chdir and user.name=root"sysdig -A -c echo_fds fd.name=/dev/ptmx and proc.name=sshdsysdig evt.type=open and fd.name contains /etcsysdig -r file.scap -c list_login_shells tarsysdig -r trace.scap.gz -c spy_users proc.loginshellid=5459# 容器sysdig -vcontainers # 容器列表及资源使用情况sysdig -pc # 容器上下文列表sysdig -pc -c topprocs_cpu container.name=wordpress # 查看 wordpress 容器 CPU 占用率最高的进程sysdig -pc -c topprocs_net container.name=wordpress # 查看 wordpress 容器 net 占用率最高的进程sysdig -pc -c topconns container.name=wordpress # 查看 wordpress 容器 net 连接的排名情况sysdig -pc -c topfiles_bytes container.name=wordpress # 查看 wordpress 容器 I/O 字节最多的文件sysdig -pc -c spy_users container.name=wordpress # 查看 wordpress 容器所有命令的执行情况# 应用sysdig -s2000 -X -c echo_fds fd.cip=192.168.1.20 # 显示主机 192.168.1.20 的网络传输数据sysdig -s 2000 -A -c echo_fds fd.port=80 and evt.buffer contains GET # 查看机器所有的 HTTP 请求sysdig -s 2000 -A -c echo_fds evt.buffer contains SELECT # 查看机器所有的 SQL 查询sysdig -s 2000 -A -c echo_fds fd.sip=192.168.30.5 and \ proc.name=apache2 and evt.buffer contains SELECT # 查看来自 APACHE 的 SQL 查询 BCC https://github.com/iovisor/bcc 常用工具 uptime CPU + Disks 的测量，1，5，15 分钟 ps -eLf 打印线程 ps -ef f 打印进程树 pstree -alpha &lt;PID&gt; 查看某进程的详细情况 free 查看内存占用情况（下面有详细的说明） top/atop/htop/gtop 查看进程活动状态以及一些系统状况 , 常用 htop rtop 远程通过 ssh 查看其它服务器的信息 vtop node.js 的 console 查看服务器状态 iotop 查看硬盘状况排序 vmstat 综合工具 （通常使用 vmstat 1 50 注：每秒显示 1 次，共显示 50 次） dstat 综合工具 （通常使用 dstat -cmdnlpsy 注：显示所有） nmon 综合工具 glances 综合工具 # xxx 表示进程 id 或 pid /proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps sysstat 包含工具 sar 综合工具 , 查看历史 iowait 值 (Collect, report, or save system activity information) sadf -x 可以使用 xml 格式打印信息 pidstat 打印进程信息 (Report statistics for Linux tasks, 有占用信息 ) cifsiostat 查看 windows 共享的 io 状况 mpstat 查看多处理器状况 （通常使用 mpstat -P ALL 5 2 注：对所有 CPU，每次花费 5 秒收集 5 个，共收集 2 次的） iostat 查看 CPU 负载，硬盘状况 （通常使用 iostat -xnz 1） 网络监测工具 ifstat/bwm/nethogs # 查看网络 in/out 状况 iftop/iptraf # 实时网络状况监测 ( 常用 -pn)，查找正在使用带宽的套接字连接或进程 netstat # 查看网络状况 ( 常用 -tupnl) netstat -p &lt;PID&gt; # 可以查看该进程的所有调用文件 slurm # yet another network load monitor tcpdump # 抓取网络数据包，详细分析 wireshark # 抓取网络数据包，详细分析 Tcptrace # 数据包分析工具 (windows 下有 ) tcptrack # monitor your server network connections and bandwidth tshark ngrep ngrep -qd any -W byline . tcp dst port 2003 ## any 匹配所有接口，. 匹配所有内容 目标端口为 2003 的包 ngrep -qd any -W byline &quot;^(GET|POST)&quot; port not 22 # 相当于： tcpdump &#39;port 5901 and (host 192.168.109.1)&#39; iperf # 测试 TCP 和 UDP 带宽质量 # 服务端 : iperf [ -u] -s 客户端 : iperf [-u] -c IP_ADDR_OF_SERVER -f M -t 60 -P 30 -b 100M (-u UDP 测试 ; -f 单位 , 可以是 kmKM; -t 测试时间 ; -P 线程数 ; -b 测试数据包大小 ) speed-test # 网速测试工具 npm install --global speed-test traceroute/mtr/dig # trace 工具 tcptrace # 不在 linux 默认，需要安装 ss -l/-s # Socket Statistics pstree -alpha # ps 树形列表 pstree -al pid # 单个进程的树形列表 lsof -iTCP -sTCP:ESTABLISHED # tcp/udp 网络服务 lsof -i :22 # 知道 22 端口现在运行什么程序 lsof -c abc # 显示 abc 进程现在打开的文件 lsof -p 12 # 看进程号为 12 的进程打开了哪些文件 , 等同于 pmap 12 和 netstat -p 12 lsof -U # 列出所有的 socket, 等同于 ss -l lsof | grep FILEorDir # 查看文件被哪个进程打个 lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; # 文件删除了，但是还占用空间 其它监测工具 gnome-system-monitor/conky # gnome 的 GUI 任务管理器工具 jvmtop.sh/jconsole PID # java 占用情况 / 图形界面的 java console 占用情况（很清晰，建议使用） vmtouch # 查看放到内存中的文件 pmap PID # 查看进程打开的文件 , 等同于 lsof -p PID Strace 查看内核空间，ltrace 查看用户空间 strace -e open ls # 查看命令 ls 打开的库文件 strace -r php worker.php # 查看 worker.php 的 trace strace -p &lt;PID&gt; # 查看正在运行的进程的 trace ltrace /bin/ls # 运行 /bin/ls 命令，查看这个命令具体调用哪些库 blktrace -d /dev/sda # 生成块设备的跟踪中信息，需要先 mount -t debugfs none /sys/kernel/debug, 再 blkparse stap（SystemTap）、perf、sysdig # 更深层次的系统分析以及性能分析 共享内存 ipcs -m ipcrm -m &lt;SHMID&gt; free 字段说明 1234[root@bigdata /]# freetotal used free shared buffers cachedMem: 255268 238332 16936 0 85540 126384-/+ buffers/cache: 26408 228860 free2：未被使用的 buffers 与 cache 和未被分配的内存之和，这就是系统当前实际可用内存。 total1 = used1 + free1 total1 = used2 + free2 used1 = buffers1 + cached1 + used2 free2 = buffers1 + cached1 + free1 buffer: 缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。 cache: 高速缓存，是位于 CPU 与主内存间的一种容量较小但速度很高的存储器。由于 CPU 的速度远高于主内存，CPU 直接从内存中存取数据要等待一定时间周期，Cache 中保存着 CPU 刚用过或循环使用的一部分数据，当 CPU 再次使用该部分数据时可从 Cache 中直接调用 , 这样就减少了 CPU 的等待时间 , 提高了系统的效率。Cache 又分为一级 Cache(L1 Cache) 和二级 Cache(L2 Cache)，L1 Cache 集成在 CPU 内部，L2 Cache 早期一般是焊在主板上 , 现在也都集成在 CPU 内部，常见的容量有 256KB 或 512KB L2 Cache。 总的来说： buffer : 作为 buffer cache 的内存，是块设备的读写缓冲区 cache: 作为 page cache 的内存 , 文件系统的 cache Linux 监控脚本 12345678910111213141516171819202122232425DAT="`date +%Y%m%d`"HOUR="`date +%H`"DIR="/home/oslog/host_$&#123;DAT&#125;/$&#123;HOUR&#125;"DELAY=60COUNT=60# whether the responsible directory existif ! test -d $&#123;DIR&#125;then /bin/mkdir -p $&#123;DIR&#125;fi# general checkexport TERM=linux/usr/bin/top -b -d $&#123;DELAY&#125; -n $&#123;COUNT&#125; &gt; $&#123;DIR&#125;/top_$&#123;DAT&#125;.log 2&gt;&amp;1 &amp;# cpu check/usr/bin/sar -u $&#123;DELAY&#125; $&#123;COUNT&#125; &gt; $&#123;DIR&#125;/cpu_$&#123;DAT&#125;.log 2&gt;&amp;1 &amp;#/usr/bin/mpstat -P 0 $&#123;DELAY&#125; $&#123;COUNT&#125; &gt; $&#123;DIR&#125;/cpu_0_$&#123;DAT&#125;.log 2&gt;&amp;1 &amp;#/usr/bin/mpstat -P 1 $&#123;DELAY&#125; $&#123;COUNT&#125; &gt; $&#123;DIR&#125;/cpu_1_$&#123;DAT&#125;.log 2&gt;&amp;1 &amp;# memory check/usr/bin/vmstat $&#123;DELAY&#125; $&#123;COUNT&#125; &gt; $&#123;DIR&#125;/vmstat_$&#123;DAT&#125;.log 2&gt;&amp;1 &amp;# I/O check/usr/bin/iostat $&#123;DELAY&#125; $&#123;COUNT&#125; &gt; $&#123;DIR&#125;/iostat_$&#123;DAT&#125;.log 2&gt;&amp;1 &amp;# network check/usr/bin/sar -n DEV $&#123;DELAY&#125; $&#123;COUNT&#125; &gt; $&#123;DIR&#125;/net_$&#123;DAT&#125;.log 2&gt;&amp;1 &amp;#/usr/bin/sar -n EDEV $&#123;DELAY&#125; $&#123;COUNT&#125; &gt; $&#123;DIR&#125;/net_edev_$&#123;DAT&#125;.log 2&gt;&amp;1 &amp;]]></content>
      <categories>
        <category>monitor</category>
      </categories>
      <tags>
        <tag>monitor</tag>
        <tag>sysdig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 配置 Location 总结及 Rewrite 规则写法]]></title>
    <url>%2Fweb%2FNginx%E9%85%8D%E7%BD%AElocation%E6%80%BB%E7%BB%93%E5%8F%8Arewrite%E8%A7%84%E5%88%99%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[location 正则写法 # 一个示例： location = / { # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ] } location / { # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ] } location /documents/ { # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ] } location ~ /documents/Abc { # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration CC ] } location ^~ /images/ { # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ] } location ~* \.(gif|jpg|jpeg)$ { # 匹配所有以 gif,jpg 或 jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ] } location /images/ { # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ configuration F ] } location /images/abc { # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F 与 G 的放置顺序是没有关系的 [ configuration G ] } location ~ /images/abc/ { # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ configuration H ] } location ~* /js/.*/\.js ^~ 开头表示 uri 以某个常规字符串开头，不是正则匹配 开头表示区分大小写的正则匹配 ; ~* 开头表示不区分大小写的正则匹配 / 通用匹配 , 如果没有其它匹配 , 任何请求都会匹配到 你可以看到 任何以 /images/ 开头的都会匹配到 D 并停止，FG 写在这里是没有任何意义的，H 是永远轮不到的，这里只是为了说明匹配顺序 /documents/document.html -&gt; config C 匹配到 C，往下没有任何匹配，采用 C /documents/1.jpg -&gt; configuration E 匹配到 C，往下正则匹配到 E /documents/Abc.jpg -&gt; config CC 最长匹配到 C，往下正则顺序匹配到 CC，不会往下到 E 实际使用建议 所以实际使用中，个人觉得至少有三个匹配规则定义，如下： location = / { proxy_pass http://tomcat:8080/index } # 第二个必选规则是处理静态文件请求，这是 nginx 作为 http 服务器的强项 # 有两种配置模式，目录匹配或后缀匹配 , 任选其一或搭配使用 location ^~ /static/ { root /webroot/static/; } location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ { root /webroot/res/; } # 非静态文件请求就默认是动态请求，自己根据实际把握 # 毕竟目前的一些框架的流行，带 .php,.jsp 后缀的情况很少了 location / { proxy_pass http://tomcat:8080/ } 引用 &gt; http://tengine.taobao.org/book/chapter_02.html &gt; http://nginx.org/en/docs/http/ngx_http_rewrite_module.html Rewrite 规则 rewrite 功能就是，使用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。rewrite 只能放在 server{},location{},if{} 中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 http://seanlook.com/a/we/index.php?id=1&amp;u=str 只对 /a/we/index.php 重写。语法 rewrite regex replacement [flag]; 执行 server 块的 rewrite 指令 执行 location 匹配 执行选定的 location 中的 rewrite 指令 last : 相当于 Apache 的[L]标记，表示完成 rewrite break : 停止执行当前虚拟主机的后续 rewrite 指令集 redirect : 返回 302 临时重定向，地址栏会显示跳转后的地址 permanent : 返回 301 永久重定向，地址栏会显示跳转后的地址 last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配 break 和 last 都能组织继续执行后面的 rewrite 指令 if 指令与全局变量 if 判断指令 语法为 if(condition){…}，对给定的条件 condition 进行判断。如果为真，大括号内的 rewrite 指令将被执行，if 条件 (conditon) 可以是如下任何内容： 当表达式只是一个变量时，如果值为空或任何以 0 开头的字符串都会当做 false 直接比较变量和内容时，使用 = 或 != ~ 正则表达式匹配，~*不区分大小写的匹配，!~ 区分大小写的不匹配 -f 和 !-f 用来判断是否存在文件 -d 和 !-d 用来判断是否存在目录 -e 和 !-e 用来判断是否存在文件或目录 -x 和 !-x 用来判断文件是否可执行 例如： if ($http_user_agent ~ MSIE) { rewrite ^(.*)$ /msie/$1 break; } // 如果 UA 包含 &quot;MSIE&quot;，rewrite 请求到 /msid/ 目录下 if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) { set $id $1; } // 如果 cookie 匹配正则，设置变量 $id 等于正则引用部分 if ($request_method = POST) { return 405; } // 如果提交方法为 POST，则返回状态 405（Method not allowed）。return 不能返回 301,302 if ($slow) { limit_rate 10k; } // 限速，$slow 可以通过 set 指令设置 if (!-f $request_filename){ break; proxy_pass http://127.0.0.1; } // 如果请求的文件名不存在，则反向代理到 localhost 。这里的 break 也是停止 rewrite 检查 if ($args ~ post=140){ rewrite ^ http://example.com/ permanent; } // 如果 query string 中包含 &quot;post=140&quot;，永久重定向到 example.com location ~* \.(gif|jpg|png|swf|flv)$ { valid_referers none blocked www.jefflei.com www.leizhenfang.com; if ($invalid_referer) { return 404; } // 防盗链 } 全局变量 下面是可以用作 if 判断的全局变量 $args ： # 这个变量等于请求行中的参数，同 $query_string $content_length ： 请求头中的 Content-length 字段。 $content_type ： 请求头中的 Content-Type 字段。 $document_root ： 当前请求在 root 指令中指定的值。 $host ： 请求主机头字段，否则为服务器名称。 $http_user_agent ： 客户端 agent 信息 $http_cookie ： 客户端 cookie 信息 $limit_rate ： 这个变量可以限制连接速率。 $request_method ： 客户端请求的动作，通常为 GET 或 POST。 $remote_addr ： 客户端的 IP 地址。 $remote_port ： 客户端的端口。 $remote_user ： 已经经过 Auth Basic Module 验证的用户名。 $request_filename ： 当前请求的文件路径，由 root 或 alias 指令与 URI 请求生成。 $scheme ： HTTP 方法（如 http，https）。 $server_protocol ： 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1。 $server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。 $server_name ： 服务器名称。 $server_port ： 请求到达服务器的端口号。 $request_uri ： 包含请求参数的原始 URI，不包含主机名，如：” /foo/bar.php?arg=baz ”。 例：http://localhost:88/test1/test2/test.php $host：localhost $server_port：88 $request_uri：http://localhost:88/test1/test2/test.php $document_uri：/test1/test2/test.php $document_root：/var/www/html $request_filename：/var/www/html/test1/test2/test.php 常用正则 . ： 匹配除换行符以外的任意字符 ? ： 重复 0 次或 1 次 + ： 重复 1 次或更多次 * ： 重复 0 次或更多次 \d ：匹配数字 ^ ： 匹配字符串的开始 $ ： 匹配字符串的介绍 {n} ： 重复 n 次 {n,} ： 重复 n 次或更多次 [c] ： 匹配单个字符 c [a-z] ： 匹配 a-z 小写字母的任意一个 小括号 () 之间匹配的内容，可以在后面通过 $1 来引用，$2 表示的是前面第二个 () 里的内容。正则里面容易让人困惑的是 \ 转义特殊字符。 rewrite 实例 例 1： http { # 定义 image 日志格式 log_format imagelog ‘[$time_local]’ $image_file ‘’ $image_type ‘’ $body_bytes_sent ‘’ $status; # 开启重写日志 rewrite_log on; server { root /home/www; location / { # 重写规则信息 error_log logs/rewrite.log notice; # 注意这里要用‘’单引号引起来，避免 {} rewrite &#39;^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$&#39; /data?file=$3.$4; # 注意不能在上面这条规则后面加上“ last ”参数，否则下面的 set 指令不会执行 set $image_file $3; set $image_type $4; } location /data { # 指定针对图片的日志格式，来分析图片类型和大小 access_log logs/images.log mian; root /data/images; # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个 url 里 try_files /$arg_file /image404.html; } location = /image404.html { # 图片不存在返回特定的信息 return 404 &quot;image not found\n&quot;; } } rewrite ^/images/(.*)_(\d+)x(\d+)\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;height=$3? last; http://www.nginx.cn/216.html http://www.ttlsa.com/nginx/nginx-rewriting-rules-guide/ 老僧系列 nginx 之 rewrite 规则快速上手 http://fantefei.blog.51cto.com/2229719/919431 来源： http://seanlook.com/2015/05/17/nginx-location-rewrite/]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>location</tag>
        <tag>rewrite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令与使用]]></title>
    <url>%2Flinux%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/f7b5431418d2 猴子都能懂的 git 入门：https://backlog.com/git-tutorial/cn/intro/intro5_2.html 常见问题 使用 key 方式认证 12345678# start the ssh-agent in the backgroundeval "$(ssh-agent -s)" Agent pid 59566ssh-add ~/.ssh/id_rsa# 测试ssh git@github.com # 删除以下文件夹中的文件： %appdata%\..\Local\Microsoft\Credentials # 但是还是好麻烦，请看下面 同一网站，多个不同的帐号使用 git key 切换 安装 Git 安装 TortoiseGit (Windows 下初学者推荐 ) 在安装时指定 ssh，而不是 plink vi ~/.ssh/config 1234567891011121314151617181920212223##--------------------------------------------------------------------------# &lt;GIT_DOMAIN&gt;#--------------------------------------------------------------------------## git clone git@&lt;ID1&gt;.&lt;GIT_DOMAIN&gt;:&lt;GIT_USER1&gt;/&lt;GIT_REPO1&gt;.githost &lt;ID1&gt;.&lt;GIT_DOMAIN&gt; hostname &lt;GIT_DOMAIN&gt; Port 22 User &lt;GIT_USER&gt; IdentityFile ~/.ssh/&lt;GIT_DOMAIN&gt;-&lt;GIT_USER&gt;-id_rsa##--------------------------------------------------------------------------# &lt;GIT_DOMAIN&gt;#--------------------------------------------------------------------------## git clone git@&lt;ID2&gt;.&lt;GIT_DOMAIN&gt;:&lt;GIT_USER2&gt;/&lt;GIT_REPO2&gt;.githost &lt;ID2&gt;.&lt;GIT_DOMAIN&gt; hostname &lt;GIT_DOMAIN&gt; Port 22 User &lt;GIT_USER&gt; IdentityFile ~/.ssh/&lt;GIT_DOMAIN&gt;-&lt;GIT_USER&gt;-id_rsa 使用不同的 ssh 别名连接 Git (host 后面接的即为别名 ) 取消 global 的 email git config --global --unset user.name git config --global --unset user.email 设置项目级自己的 email git config user.email &quot;xxxx@xx.com&quot; git config user.name &quot;suzie&quot; 使用 ssh config http://memoryboxes.github.io/blog/2014/12/07/duo-ge-gitzhang-hao-zhi-jian-de-qie-huan/ vi ~/.ssh/config 12345678910111213# 在主机 lb.gogs.pro.svi.pub 上的 svicloud 用户host svicloud.lb.gogs.pro.svi.pub hostname lb.gogs.pro.svi.pub Port 22 User svicloud IdentityFile ~/.ssh/id_rsa_first# 在主机 lb.gogs.pro.svi.pub 上的 svicloud 用户host svicloud.lb.gogs.pro.svi.pub hostname lb.gogs.pro.svi.pub Port 22 User svicloud IdentityFile ~/.ssh/id_rsa_first 清除 git 路径中的所有 .git 文件 $ find . -name &quot;.git&quot; | xargs rm -Rf $ git archive --remote=${GIT_REPO} latest www | tar xvf - -C /tmp 常用配置 配置认证、支持中文 # 配置用户名和 email $ git config --global user.name &quot;dongcj&quot; $ git config --global user.email &quot;ntwk@163.com&quot; $ git config --global core.autocrlf true $ git config --list 重新设置 git url 或 新增远程仓库 # 重新设置远程仓库地址 $ git remote set-url origin git@github.com:dongcj/blog.git $ git remote add origin git@github.com:dongcj/blog.git git 日常用法 123456789101112git status # 查看当前版本状态（是否修改）git ls-files # 列出 git index 包含的文件git add xyz # 添加 xyz 文件至 indexgit add . # 增加当前子目录下所有更改过的文件至 indexgit commit -m 'xxx' # 提交git commit --amend -m 'xxx' # ` 合并 ` 上一次提交（用于反复修改）git commit -am 'xxx' # 将 add 和 commit 合为一步git rm xxx # 删除 index 中的文件git rm -r * # 递归删除 git log 12345678910git log # 显示提交日志git log -1 # 显示 1 行日志 -n 为 n 行git log -p test.html # 显示 test.html 的变更日志git log --stat # 显示提交日志及相关变动文件git log -p -m # 显示每个文件修改记录git log v2.0 # 显示 v2.0 的日志git log --pretty=format:'%h %s' --graph # 图示提交日志git reflog # 显示所有提交，包括孤立节点# 显示最近 20 条提交记录git --no-pager log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr [%an])%Creset' --abbrev-commit --date=relative -20 更多格式化输出 : https://ruby-china.org/topics/939 git show 1234567891011git show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交修改的详细内容git show dfb02 # 可只用 commitid 的前几位git show HEAD # 显示 HEAD 提交日志git show v2.0 # 显示 v2.0 的日志及详细内容git show HEAD^ # 显示 HEAD 的父（上一个版本）的提交日志 ^^ 为上两个版本 ^5 为上 5 个版本git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史git show HEAD~3git show -s --pretty=raw 2be7fcb476git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示 master 分支昨天的状态 git diff 123456git diff # 显示所有未添加至 index 的变更git diff --cached # 显示所有已添加 index 但还未 commit 的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与 HEAD 版本 lib 目录的差异git diff origin/master..master # 比较远程分支 master 上有本地分支 master 上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 git branch 123456789git branch # 显示本地分支git branch --contains 50089 # 显示包含提交 50089 的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git branch -d hotfixes/BJVEP933 # 删除分支 hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支 hotfixes/BJVEP933 git checkout 12345678git checkout abcde file/to/restore # 单一文件回退到某个版本git checkout -b master_copy # 从当前分支创建新分支 master_copy 并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的 features/performance 分支git checkout --track hotfixes/BJVEP933 # 检出远程分支 hotfixes/BJVEP933 并创建本地跟踪分支git checkout v2.0 # 检出版本 v2.0git checkout -b devel origin/develop # 从远程分支 develop 创建新本地分支 devel 并检出git checkout -- README # 检出 head 版本的 README 文件（可用于修改错误回退） git fetch 12345git fetch # 获取所有远程分支（不更新本地分支，另需 merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git fetch --all # 1. 获取所有远程分支git reset --hard origin/master # 2. 先运行 1，再使用远程文件 &lt;b&gt; 强制覆盖 &lt;/b&gt; 本地文件git reset --hard HEAD # 将当前版本重置为 HEAD（通常用于 merge 失败回退） git tag 1234567891011121314151617git tag # git 列表git tag v0.1.1 # 打标签git tag v0.1.1 6224937 # 补打标签git tag v0.1.2-light # 创建轻量标签 - 轻量标签是指向提交对象的引用 ( 暂时没用到 )git tag -a v0.1.2 -m "0.1.2 版本备注 " # 附注标签则是仓库中的一个独立对象。建议使用附注标签git tag -a v0.1.1 9fbc3d0 # 给指定的 commit 打标签（即补打标签）git checkou [tagname] # 切换标签git tag -d v0.1.2 # 删除标签git push origin :refs/tags/v0.9 # 删除远程标签 ( 需要先删除本地标签 )git push origin v0.1.2 # 提交单一标签git push origin --tags # 提交所有标签git show v1.2.5 # 查看标签内容git tag -l | xargs git tag -d # Delete local tags.git fetch # Fetch remote tags.git tag -l | xargs -n 1 git push --delete origin # Delete remote tags.git tag -l | xargs git tag -d # Delete local tasg. 其它命令 123456789git merge origin/master # 合并远程 master 分支至当前分支git push origin master # 将当前分支 push 到远程 master 分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的 hotfixes/BJVEP933 分支git push --tags # 把所有 tag 推送到远程仓库git mv README README2 # 重命名文件 README 为 README2git rebase]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>